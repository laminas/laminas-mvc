{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"controllers/","text":"Available Controllers Controllers in laminas-mvc are objects implementing Laminas\\Stdlib\\DispatchableInterface . That interface describes a single method: use Laminas\\Stdlib\\DispatchableInterface; use Laminas\\Stdlib\\RequestInterface as Request; use Laminas\\Stdlib\\ResponseInterface as Response; class Foo implements DispatchableInterface { public function dispatch(Request $request, Response $response = null) { // ... do something, and preferably return a Response ... } } While the pattern is straight-forward, chances are you don't want to implement custom dispatch logic for every controller, particularly as it's not unusual or uncommon for a single controller to handle several related types of requests. To provide convenience, laminas-mvc also defines several interfaces that, when implemented, can provide controllers with additional capabilities. Common Interfaces Used With Controllers InjectApplicationEvent The Laminas\\Mvc\\InjectApplicationEventInterface hints to the Application instance that it should inject its MvcEvent into the controller itself. Why would this be useful? Recall that the MvcEvent composes a number of objects: the Request and Response , naturally, but also the router, the route matches (a RouteMatch instance), and potentially the \"result\" of dispatching. A controller that has the MvcEvent injected, then, can retrieve or inject these. As an example: $matches = $this->getEvent()->getRouteMatch(); $id = $matches->getParam('id', false); if (! $id) { $response = $this->getResponse(); $response->setStatusCode(500); $this->getEvent()->setResult('Invalid identifier; cannot complete request'); return; } The InjectApplicationEventInterface defines two methods: public function setEvent(Laminas\\EventManager\\EventInterface $event); public function getEvent(); ServiceLocatorAware In most cases, you should define your controllers such that dependencies are injected by the application's ServiceManager , via either constructor arguments or setter methods. However, occasionally you may have objects you wish to use in your controller that are only valid for certain code paths. Examples include forms, paginators, navigation, etc. In these cases, you may decide that it doesn't make sense to inject those objects every time the controller is used. The ServiceLocatorAwareInterface interface hints to the ServiceManager that it should inject itself into the controller. It defines two simple methods: use Laminas\\ServiceManager\\ServiceLocatorInterface; use Laminas\\ServiceManager\\ServiceLocatorAwareInterface; public function setServiceLocator(ServiceLocatorInterface $serviceLocator); public function getServiceLocator(); ServiceLocatorInterface is deprecated ServiceLocatorAwareInterface was removed from laminas-servicemanager v3.0 , and, as such, starting in laminas-mvc 2.7.0, the AbstractController implementation no longer implements the interface, though it implements the methods the interface defines; this allows forwards compatibility with laminas-servicemanager v3. However, also starting with the laminas-mvc 2.7.0 release, ServiceLocatorAwareInterface usage is deprecated. We recommend injecting dependencies explicitly instead of pulling them from a composed ServiceManager instance. In cases where an object will not be used in all code paths, we recommend splitting into discrete controllers, or using lazy services . EventManagerAware Typically, it's nice to be able to tie into a controller's workflow without needing to extend it or hardcode behavior into it. The solution for this is to use the EventManager . You can hint to the ServiceManager that you want an EventManager injected by implementing the interface EventManagerAwareInterface , which tells the ServiceManager to inject an EventManager . To do this, you define two methods. The first, a setter, should also set any SharedEventManager identifiers you want to listen on, and the second, a getter, should return the composed EventManager instance. use Laminas\\EventManager\\EventManagerAwareInterface; use Laminas\\EventManager\\EventManagerInterface; public function setEventManager(EventManagerInterface $events); public function getEventManager(); Controller Plugins Code re-use is a common goal for developers. Another common goal is convenience. However, this is often difficult to achieve cleanly in abstract, general systems. Within your controllers, you'll often find yourself repeating tasks from one controller to another. Some common examples: Generating URLs. Redirecting. Setting and retrieving flash messages (self-expiring session messages). Invoking and dispatching additional controllers. To facilitate these actions while also making them available to alternate controller implementations, we've created a PluginManager implementation for the controller layer, Laminas\\Mvc\\Controller\\PluginManager , building on the Laminas\\ServiceManager\\AbstractPluginManager functionality. To utilize it, implement the setPluginManager(PluginManager $plugins) method, and set up your code to use the controller-specific implementation by default: use Laminas\\Mvc\\Controller\\PluginManager; public function setPluginManager(PluginManager $plugins) { $this->plugins = $plugins; $this->plugins->setController($this); return $this; } public function getPluginManager() { if (!$this->plugins) { $this->setPluginManager(new PluginManager()); } return $this->plugins; } public function plugin($name, array $options = null) { return $this->getPluginManager()->get($name, $options); } AbstractActionController Implementing each of the above interfaces is a lesson in redundancy; you won't often want to do it. As such, we've developed abstract, base controllers you can extend to get started. The first is Laminas\\Mvc\\Controller\\AbstractActionController . This controller implements each of the above interfaces, and uses the following assumptions: An \"action\" parameter is expected in the RouteMatch object composed in the attached MvcEvent . If none is found, a notFoundAction() is invoked. The \"action\" parameter is converted to a camelCased format and appended with the word \"Action\" to create a method name. As examples: \"foo\" maps to fooAction , \"foo-bar\" or \"foo.bar\" or \"foo_bar\" to fooBarAction . The controller then checks to see if that method exists. If not, the notFoundAction() method is invoked; otherwise, the discovered method is called. The results of executing the given action method are injected into the MvcEvent 's \"result\" property (via setResult() , and accessible via getResult() ). Essentially, a route mapping to an AbstractActionController needs to return both the \"controller\" and \"action\" keys in its matches. Creation of action controllers looks like the following example: namespace Foo\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; class BarController extends AbstractActionController { public function bazAction() { return ['title' => __METHOD__]; } public function batAction() { return ['title' => __METHOD__]; } } Interfaces and Collaborators AbstractActionController implements each of the following interfaces: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\InjectApplicationEventInterface Laminas\\ServiceManager\\ServiceLocatorAwareInterface (starting with laminas-mvc 2.7.0, only the methods defined by the interface, not the interface itself) Laminas\\EventManager\\EventManagerAwareInterface The composed EventManager will be configured to listen on the following contexts: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\Controller\\AbstractActionController Laminas\\Mvc\\Controller\\AbstractController Additionally, if you extend the class, it will listen on the name of the extending class. AbstractRestfulController Laminas\\Mvc\\Controller\\AbstractRestfulController provides a native RESTful implementation that maps HTTP request methods to controller methods, using the following matrix: GET maps to either get() or getList() , depending on whether or not an \"id\" parameter is found in the route matches. If one is, it is passed as an argument to get() ; if not, getList() is invoked. In the former case, you should provide a representation of the given entity with that identification; in the latter, you should provide a list of entities. POST maps to create() . That method expects a $data argument, usually the $_POST superglobal array. The data should be used to create a new entity, and the response should typically be an HTTP 201 response with the Location header indicating the URI of the newly created entity and the response body providing the representation. PUT maps to update() , and requires that an \"id\" parameter exists in the route matches; that value is passed as an argument to the method. It should attempt to update the given entity, and, if successful, return either a 200 or 202 response status, as well as the representation of the entity. DELETE maps to delete() , and requires that an \"id\" parameter exists in the route matches; that value is passed as an argument to the method. It should attempt to delete the given entity, and, if successful, return either a 200 or 204 response status. Additionally, you can map \"action\" methods to the AbstractRestfulController , just as you would in the AbstractActionController ; these methods will be suffixed with \"Action\", differentiating them from the RESTful methods listed above. This allows you to perform such actions as providing forms used to submit to the various RESTful methods, or to add RPC methods to your RESTful API. Interfaces and Collaborators AbstractRestfulController implements each of the following interfaces: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\InjectApplicationEventInterface Laminas\\ServiceManager\\ServiceLocatorAwareInterface (starting with laminas-mvc 2.7.0, only the methods defined by the interface, not the interface itself) Laminas\\EventManager\\EventManagerAwareInterface The composed EventManager will be configured to listen on the following contexts: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\Controller\\AbstractRestfulController Laminas\\Mvc\\Controller\\AbstractController Additionally, if you extend the class, it will listen on the name of the extending class. AbstractConsoleController For version 3, the integration component laminas-mvc-console must be installed. It can be done via Composer: `bash composer require laminas/laminas-mvc-console If you are not using the component installer, you will need to add this component as a module . Laminas\\Mvc\\Console\\Controller\\AbstractConsoleController extends from AbstractActionController and provides the following functionality: The method setConsole(Laminas\\Console\\Adapter\\AdapterInterface $console) allows injecting a console adapter representing the current console environment. By default, the ControllerManager will inject this for you as part of controller instantiation. The method getConsole() allows you to retrieve the current console adapter instance, allowing you to retrieve console capabilities and generate console output. The dispatch() method will throw an exception if invoked in a non-console environment, ensuring that you do not need to do any checks within your action methods for the environment. Interfaces and Collaborators AbstractRestfulController implements each of the following interfaces: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\InjectApplicationEventInterface Laminas\\ServiceManager\\ServiceLocatorAwareInterface (starting with laminas-mvc 2.7.0, only the methods defined by the interface, not the interface itself) Laminas\\EventManager\\EventManagerAwareInterface The composed EventManager will be configured to listen on the following contexts: Laminas\\Stdlib\\DispatchableInterface Laminas\\Mvc\\Console\\Controller\\AbstractConsoleController Laminas\\Mvc\\Controller\\AbstractActionController Laminas\\Mvc\\Controller\\AbstractController Additionally, if you extend the class, it will listen on the name of the extending class.","title":"Available Controllers"},{"location":"controllers/#available-controllers","text":"Controllers in laminas-mvc are objects implementing Laminas\\Stdlib\\DispatchableInterface . That interface describes a single method: use Laminas\\Stdlib\\DispatchableInterface; use Laminas\\Stdlib\\RequestInterface as Request; use Laminas\\Stdlib\\ResponseInterface as Response; class Foo implements DispatchableInterface { public function dispatch(Request $request, Response $response = null) { // ... do something, and preferably return a Response ... } } While the pattern is straight-forward, chances are you don't want to implement custom dispatch logic for every controller, particularly as it's not unusual or uncommon for a single controller to handle several related types of requests. To provide convenience, laminas-mvc also defines several interfaces that, when implemented, can provide controllers with additional capabilities.","title":"Available Controllers"},{"location":"controllers/#common-interfaces-used-with-controllers","text":"","title":"Common Interfaces Used With Controllers"},{"location":"controllers/#abstractactioncontroller","text":"Implementing each of the above interfaces is a lesson in redundancy; you won't often want to do it. As such, we've developed abstract, base controllers you can extend to get started. The first is Laminas\\Mvc\\Controller\\AbstractActionController . This controller implements each of the above interfaces, and uses the following assumptions: An \"action\" parameter is expected in the RouteMatch object composed in the attached MvcEvent . If none is found, a notFoundAction() is invoked. The \"action\" parameter is converted to a camelCased format and appended with the word \"Action\" to create a method name. As examples: \"foo\" maps to fooAction , \"foo-bar\" or \"foo.bar\" or \"foo_bar\" to fooBarAction . The controller then checks to see if that method exists. If not, the notFoundAction() method is invoked; otherwise, the discovered method is called. The results of executing the given action method are injected into the MvcEvent 's \"result\" property (via setResult() , and accessible via getResult() ). Essentially, a route mapping to an AbstractActionController needs to return both the \"controller\" and \"action\" keys in its matches. Creation of action controllers looks like the following example: namespace Foo\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; class BarController extends AbstractActionController { public function bazAction() { return ['title' => __METHOD__]; } public function batAction() { return ['title' => __METHOD__]; } }","title":"AbstractActionController"},{"location":"controllers/#abstractrestfulcontroller","text":"Laminas\\Mvc\\Controller\\AbstractRestfulController provides a native RESTful implementation that maps HTTP request methods to controller methods, using the following matrix: GET maps to either get() or getList() , depending on whether or not an \"id\" parameter is found in the route matches. If one is, it is passed as an argument to get() ; if not, getList() is invoked. In the former case, you should provide a representation of the given entity with that identification; in the latter, you should provide a list of entities. POST maps to create() . That method expects a $data argument, usually the $_POST superglobal array. The data should be used to create a new entity, and the response should typically be an HTTP 201 response with the Location header indicating the URI of the newly created entity and the response body providing the representation. PUT maps to update() , and requires that an \"id\" parameter exists in the route matches; that value is passed as an argument to the method. It should attempt to update the given entity, and, if successful, return either a 200 or 202 response status, as well as the representation of the entity. DELETE maps to delete() , and requires that an \"id\" parameter exists in the route matches; that value is passed as an argument to the method. It should attempt to delete the given entity, and, if successful, return either a 200 or 204 response status. Additionally, you can map \"action\" methods to the AbstractRestfulController , just as you would in the AbstractActionController ; these methods will be suffixed with \"Action\", differentiating them from the RESTful methods listed above. This allows you to perform such actions as providing forms used to submit to the various RESTful methods, or to add RPC methods to your RESTful API.","title":"AbstractRestfulController"},{"location":"controllers/#abstractconsolecontroller","text":"For version 3, the integration component laminas-mvc-console must be installed. It can be done via Composer: `bash composer require laminas/laminas-mvc-console If you are not using the component installer, you will need to add this component as a module . Laminas\\Mvc\\Console\\Controller\\AbstractConsoleController extends from AbstractActionController and provides the following functionality: The method setConsole(Laminas\\Console\\Adapter\\AdapterInterface $console) allows injecting a console adapter representing the current console environment. By default, the ControllerManager will inject this for you as part of controller instantiation. The method getConsole() allows you to retrieve the current console adapter instance, allowing you to retrieve console capabilities and generate console output. The dispatch() method will throw an exception if invoked in a non-console environment, ensuring that you do not need to do any checks within your action methods for the environment.","title":"AbstractConsoleController"},{"location":"examples/","text":"Examples Controllers Accessing the Request and Response When using one of the abstract controller implementations, the request and response object are composed directly into the controller as soon as dispatch() is called. You may access them as follows: // Using explicit accessor methods $request = $this->getRequest(); $response = $this->getResponse(); // Using direct property access $request = $this->request; $response = $this->response; Additionally, if your controller implements InjectApplicationEventInterface (as all shipped abstract controllers do), you can access these objects from the attached MvcEvent : $event = $this->getEvent(); $request = $event->getRequest(); $response = $event->getResponse(); The above can be useful when composing event listeners into your controller. Accessing routing parameters The parameters returned when routing completes are wrapped in a Laminas\\Router\\RouteMatch object. This object is detailed in the section on Routing . Within your controller, if you implement InjectApplicationEventInterface (as all shipped abstract controllers do), you can access this object from the attached MvcEvent : $event = $this->getEvent(); $matches = $event->getRouteMatch(); Once you have the RouteMatch object, you can pull parameters from it. The same can be done using the Params plugin . Returning early You can short-circuit execution of the application at any point by returning a Response from your controller or any event. When such a value is discovered, it halts further execution of the event manager, bubbling up to the Application instance, where it is immediately returned. As an example, the Redirect plugin returns a Response , which can be returned immediately so as to complete the request as quickly as possible. Other use cases might be for returning JSON or XML results from web service endpoints, returning \"401 Unauthorized\" results, etc. Bootstrapping Registering module-specific listeners You may want module-specific listeners; these allow you to introduce authorization, logging, caching, or other concerns into your application. Each Module class can have an optional onBootstrap() method. This method is used for module-specific configuration, and is the ideal location to setup event listeners for you module. The onBootstrap() method is called for every module on every page request and should only be used for performing lightweight tasks such as registering event listeners. The base Application class shipped with the framework has an EventManager associated with it, and once the modules are initialized, it triggers the bootstrap event, which provides a getApplication() method on the event. One way to accomplish module-specific listeners is to listen to that event, and register listeners at that time. As an example: namespace SomeCustomModule; class Module { /** * @param \\Laminas\\Mvc\\MvcEvent $e The MvcEvent instance * @return void */ public function onBootstrap($e) { $application = $e->getApplication(); $config = $application->getConfig(); $view = $application->getServiceManager()->get('ViewHelperManager'); // You must have these keys in you application config $view->headTitle($config['view']['base_title']); // This is your custom listener $listener = new Listeners\\ViewListener(); $listener->setView($view); $listener->attach($application->getEventManager()); } } The above demonstrates several things. First, it demonstrates a listener on the application's bootstrap event (the onBootstrap() method). Second, it demonstrates that listener, and how it can be used to register listeners with the application. It grabs the Application instance; from the Application , it is able to grab the attached service manager and configuration. These are then used to retrieve the view, configure some helpers, and then register a listener aggregate with the application event manager.","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#controllers","text":"","title":"Controllers"},{"location":"examples/#bootstrapping","text":"","title":"Bootstrapping"},{"location":"intro/","text":"Introduction laminas-mvc is the MVC layer shipped with Laminas and above, and focuses on performance and flexibility. The MVC layer is built on top of the following components: laminas-servicemanager - laminas-mvc provides a set of default service definitions, used to create and configure the application instance and workflow. laminas-eventmanager - The MVC is event driven, and uses events for the initial bootstrapping of the application, for returning response and request calls, for matching routes, and even for rendering views. laminas-http - specifically the request and response objects from the Laminas\\Http\\PhpEnvironment namespace, which provide objects that ensure the request is injected with the current environment (including query parameters, POST parameters, HTTP headers, etc.), and that the response will interact correctly with the SAPI and output buffering. laminas-stdlib - specifically Laminas\\Stdlib\\DispatchableInterface . All \"controllers\" are simply dispatchable objects. laminas-router - provides routing of a request. In other words, it matches the request to its respective controller (or dispatchable). Within the MVC layer, several sub-components are exposed: Laminas\\Mvc\\Controller , a set of abstract \"controller\" classes with basic responsibilities such as event wiring, action dispatching, etc., as well as controller plugins. Laminas\\Mvc\\Service provides a set of laminas-servicemanager factories and definitions for the default application workflow. Laminas\\Mvc\\View provides default wiring for renderer selection, view script resolution, helper registration, and more; additionally, it provides a number of listeners that tie into the MVC workflow, providing features such as automated template name resolution, automated view model creation and injection, etc. The gateway to the MVC is the Laminas\\Mvc\\Application object (referred to as Application henceforth). Its primary responsibilities are to bootstrap resources, to route the request, and to retrieve and dispatch the controller matched during routing. Once accomplished, it will render the view, and finish the request, returning and sending the response. Basic Application Structure The basic application structure follows: application_root/ config/ application.config.php autoload/ global.php local.php // etc. data/ module/ vendor/ public/ .htaccess index.php init_autoloader.php The public/index.php script marshals all user requests to your website, retrieving an array of configuration from config/application.config.php . On return, it run() s the Application , processing the request and returning a response to the user. The config directory as described above contains configuration used by laminas-modulemanager to load modules and merge configuration (e.g., database configuration and credentials); we will detail this more later. The vendor sub-directory should contain any third-party modules or libraries on which your application depends. This might include Laminas, custom libraries from your organization, or other third-party libraries from other projects. Libraries and modules placed in the vendor sub-directory should not be modified from their original, distributed state. Typically, this directory will be managed by Composer . Finally, the module directory will contain one or more modules delivering your application's functionality. Let's now turn to modules, as they are the basic units of a web application. Basic Module Structure A module may contain anything: PHP code, including MVC functionality; library code; view scripts; and/or or public assets such as images, CSS, and JavaScript. The only requirement \u2014 and even this is optional \u2014 is that a module acts as a PHP namespace and that it contains a Module class under that namespace. This class is eventually consumed by laminas-modulemanager to perform a number of tasks. The recommended module structure follows: module_root<named-after-module-namespace>/ Module.php autoload_classmap.php autoload_function.php autoload_register.php config/ module.config.php public/ images/ css/ js/ src/ <module_namespace>/ <code files> test/ phpunit.xml bootstrap.php <module_namespace>/ <test code files> view/ <dir-named-after-module-namespace>/ <dir-named-after-a-controller>/ <.phtml files> Since a module acts as a namespace, the module root directory should be that namespace. This namespace could also include a vendor prefix of sorts. As an example a module centered around \"User\" functionality delivered by Laminas might be named \"LaminasUser\", and this is also what the module root directory will be named. Source and test code organization The above details a PSR-0 structure for the source and test code directories. You can also use PSR-4 so long as you have setup autoloading correctly to do so. The Module.php file directly under the module root directory will be in the module namespace shown below. namespace LaminasUser; class Module { } Module class location If you have an autoloader defined, such as detailed later around the various autoload_*.php files or using Composer's autoloading features , then your Module.php file can be co-located with your source code. Our current recommendation is to define autoloading for your application-specific modules via Composer. When an init() method is defined, this method will be triggered by a laminas-modulemanager listener when it loads the module class, and passed a ModuleManager instance by default. This allows you to perform tasks such as setting up module-specific event listeners. But be cautious, the init() method is called for every module on every page request and should only be used for performing lightweight tasks such as registering event listeners. Similarly, an onBootstrap() method (which accepts an MvcEvent instance) may be defined; it is also triggered for every page request, and should be used for lightweight tasks as well. The three autoload_*.php files are not required, but recommended if you are not using Composer to provide autoloading for your module. They provide the following: File Description autoload_classmap.php Should return an array classmap of class name/filename pairs (with the filenames resolved via the __DIR__ magic constant). autoload_function.php Should return a PHP callback that can be passed to spl_autoload_register() . Typically, this callback should utilize the map returned by autoload_classmap.php. autoload_register.php should register a PHP callback (is typically returned by autoload_function.php with spl_autoload_register() . The point of these three files is to provide reasonable default mechanisms for autoloading the classes contained in the module, thus providing a trivial way to consume the module without requiring laminas-modulemanager (e.g., for use outside a Laminas application). The config directory should contain any module-specific configuration. These files may be in any format laminas-config supports. We recommend naming the main configuration module.config.<format> (e.g., for PHP-based configuration, module.config.php ). Typically, you will create configuration for the router as well as for the service manager. The src directory should be a PSR-0 or PSR-4 compliant directory structure with your module's source code. The test directory should contain your unit tests. Typically, these are written using PHPUnit . The public directory can be used for assets that you may want to expose in your application's document root. These might include images, CSS files, JavaScript files, etc. How these are exposed is left to the developer. The view directory contains view scripts related to your controllers. Bootstrapping an Application The Application has seven basic dependencies. configuration , usually an array or object implementing Traversable . ServiceManager instance. EventManager instance, which, by default, is pulled from the ServiceManager , by the service name \"EventManager\". SharedEventManager instance, which, by default, is pulled from the ServiceManager , by the service name \"SharedEventManager\"; this is injected into the EventManager instance, and then pushed into every new EventManager instance created. ModuleManager instance, which, by default, is pulled from the ServiceManager , by the service name \"ModuleManager\". Request instance, which, by default, is pulled from the ServiceManager , by the service name \"Request\". Response instance, which, by default, is pulled from the ServiceManager , by the service name \"Response\". These may be satisfied at instantiation: use Laminas\\EventManager\\EventManager; use Laminas\\EventManager\\SharedEventManager; use Laminas\\Http\\PhpEnvironment; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\Application; use Laminas\\ServiceManager\\ServiceManager; $config = include 'config/application.config.php'; $serviceManager = new ServiceManager(); $serviceManager->setService('SharedEventManager', new SharedEventManager()); $serviceManager->setService('ModuleManager', new ModuleManager($config)); $serviceManager->setService('Request', new PhpEnvironment\\Request()); $serviceManager->setService('Response', new PhpEnvironment\\Response()); $serviceManager->setFactory('EventManager', function ($serviceManager) { return new EventManager($serviceManager->get('SharedEventManager')); }); $serviceManager->setShared('EventManager', false); $application = new Application($config, $serviceManager); Once you've done this, there are two additional actions you can take. The first is to \"bootstrap\" the application. In the default implementation, this does the following: Attaches the default route listener ( Laminas\\Mvc\\RouteListener ). Attaches the middleware dispatch listener ( Laminas\\Mvc\\MiddlewareListener ) (v2.7.0 and up). Attaches the default dispatch listener ( Laminas\\Mvc\\DispatchListener ). Attaches the ViewManager listener ( Laminas\\Mvc\\View\\ViewManager ). Creates the MvcEvent , and injects it with the application, request, and response; it also retrieves the router ( Laminas\\Router\\Http\\TreeRouteStack ) at this time and attaches it to the event. Triggers the \"bootstrap\" event. If you do not want these actions, or want to provide alternatives, you can do so by extending the Application class and/or manually coding what actions you want to occur. The second action you can take with the configured Application is to run() it. Calling this method performs the following: it triggers the \"route\" event, followed by the \"dispatch\" event, and, depending on execution, the \"render\" event When done, it triggers the \"finish\" event, and then returns the response instance. If an error occurs during either the \"route\" or \"dispatch\" event, a \"dispatch.error\" event is triggered as well. This is a lot to remember in order to bootstrap the application; in fact, we haven't covered all the services available by default yet. You can greatly simplify things by using the default ServiceManager configuration shipped with the MVC. use Laminas\\Loader\\AutoloaderFactory; use Laminas\\Mvc\\Service\\ServiceManagerConfig; use Laminas\\ServiceManager\\ServiceManager; // setup autoloader AutoloaderFactory::factory(); // get application stack configuration $configuration = include 'config/application.config.php'; // setup service manager $serviceManager = new ServiceManager(new ServiceManagerConfig()); $serviceManager->setService('ApplicationConfig', $configuration); // load modules -- which will provide services, configuration, and more $serviceManager->get('ModuleManager')->loadModules(); // bootstrap and run application $application = $serviceManager->get('Application'); $application->bootstrap(); $application->run(); You can make this even simpler by using the init() method of the Application . This is a static method for quick and easy initialization of the Application instance. use Laminas\\Loader\\AutoloaderFactory; use Laminas\\Mvc\\Application; use Laminas\\Mvc\\Service\\ServiceManagerConfig; use Laminas\\ServiceManager\\ServiceManager; // setup autoloader AutoloaderFactory::factory(); // get application stack configuration $configuration = include 'config/application.config.php'; // The init() method does something very similar with the previous example. Application::init($configuration)->run(); The init() does the following: Grabs the application configuration and pulls from the service_manager key, creating a ServiceManager instance with it and with the default services shipped with laminas-mvc; Creates a service named ApplicationConfig with the application configuration array; Grabs the ModuleManager service and loads the modules; bootstrap() s the Application and returns its instance. ApplicationConfig service If you use the init() method, you cannot specify a service with the name of 'ApplicationConfig' in your service manager config. This name is reserved to hold the array from application.config.php . The following services can only be overridden from application.config.php : ModuleManager SharedEventManager EventManager and Laminas\\EventManager\\EventManagerInterface All other services are configured after module loading, thus can be overridden by modules. You'll note that you have a great amount of control over the workflow. Using the ServiceManager , you have fine-grained control over what services are available, how they are instantiated, and what dependencies are injected into them. Using the EventManager 's priority system, you can intercept any of the application events (\"bootstrap\", \"route\", \"dispatch\", \"dispatch.error\", \"render\", and \"finish\") anywhere during execution, allowing you to craft your own application workflows as needed. Bootstrapping a Modular Application While the previous approach largely works, where does the configuration come from? When we create a modular application, the assumption will be that it's from the modules themselves. How do we get that information and aggregate it, then? The answer is via laminas-modulemanager. This component allows you to specify what modules the application will use; it then locates each module and initializes it. Module classes can tie into various listeners in order to provide configuration, services, listeners, and more to the application. Sounds complicated? It's not. Configuring the Module Manager The first step is configuring the module manager. Inform the module manager which modules to load, and potentially provide configuration for the module listeners. Remember the application.config.php from earlier? We're going to provide some configuration. // config/application.config.php return array( 'modules' => array( /* ... */ ), 'module_listener_options' => array( 'module_paths' => array( './module', './vendor', ), ), ); As we add modules to the system, we'll add items to the modules array. Each Module class that has configuration it wants the Application to know about should define a getConfig() method. That method should return an array or Traversable object such as a Laminas\\Config\\Config instance. As an example: namespace LaminasUser; class Module { public function getConfig() { return include __DIR__ . '/config/module.config.php' } } There are a number of other methods you can define for tasks ranging from providing autoloader configuration, to providing services to the ServiceManager , to listening to the bootstrap event. The ModuleManager documentation goes into more detail on these. Conclusion laminas-mvc is incredibly flexible, offering an opt-in, easy to create modular infrastructure, as well as the ability to craft your own application workflows via the ServiceManager and EventManager . The ModuleManager is a lightweight and simple approach to enforcing a modular architecture that encourages clean separation of concerns and code re-use.","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-mvc is the MVC layer shipped with Laminas and above, and focuses on performance and flexibility. The MVC layer is built on top of the following components: laminas-servicemanager - laminas-mvc provides a set of default service definitions, used to create and configure the application instance and workflow. laminas-eventmanager - The MVC is event driven, and uses events for the initial bootstrapping of the application, for returning response and request calls, for matching routes, and even for rendering views. laminas-http - specifically the request and response objects from the Laminas\\Http\\PhpEnvironment namespace, which provide objects that ensure the request is injected with the current environment (including query parameters, POST parameters, HTTP headers, etc.), and that the response will interact correctly with the SAPI and output buffering. laminas-stdlib - specifically Laminas\\Stdlib\\DispatchableInterface . All \"controllers\" are simply dispatchable objects. laminas-router - provides routing of a request. In other words, it matches the request to its respective controller (or dispatchable). Within the MVC layer, several sub-components are exposed: Laminas\\Mvc\\Controller , a set of abstract \"controller\" classes with basic responsibilities such as event wiring, action dispatching, etc., as well as controller plugins. Laminas\\Mvc\\Service provides a set of laminas-servicemanager factories and definitions for the default application workflow. Laminas\\Mvc\\View provides default wiring for renderer selection, view script resolution, helper registration, and more; additionally, it provides a number of listeners that tie into the MVC workflow, providing features such as automated template name resolution, automated view model creation and injection, etc. The gateway to the MVC is the Laminas\\Mvc\\Application object (referred to as Application henceforth). Its primary responsibilities are to bootstrap resources, to route the request, and to retrieve and dispatch the controller matched during routing. Once accomplished, it will render the view, and finish the request, returning and sending the response.","title":"Introduction"},{"location":"intro/#basic-application-structure","text":"The basic application structure follows: application_root/ config/ application.config.php autoload/ global.php local.php // etc. data/ module/ vendor/ public/ .htaccess index.php init_autoloader.php The public/index.php script marshals all user requests to your website, retrieving an array of configuration from config/application.config.php . On return, it run() s the Application , processing the request and returning a response to the user. The config directory as described above contains configuration used by laminas-modulemanager to load modules and merge configuration (e.g., database configuration and credentials); we will detail this more later. The vendor sub-directory should contain any third-party modules or libraries on which your application depends. This might include Laminas, custom libraries from your organization, or other third-party libraries from other projects. Libraries and modules placed in the vendor sub-directory should not be modified from their original, distributed state. Typically, this directory will be managed by Composer . Finally, the module directory will contain one or more modules delivering your application's functionality. Let's now turn to modules, as they are the basic units of a web application.","title":"Basic Application Structure"},{"location":"intro/#basic-module-structure","text":"A module may contain anything: PHP code, including MVC functionality; library code; view scripts; and/or or public assets such as images, CSS, and JavaScript. The only requirement \u2014 and even this is optional \u2014 is that a module acts as a PHP namespace and that it contains a Module class under that namespace. This class is eventually consumed by laminas-modulemanager to perform a number of tasks. The recommended module structure follows: module_root<named-after-module-namespace>/ Module.php autoload_classmap.php autoload_function.php autoload_register.php config/ module.config.php public/ images/ css/ js/ src/ <module_namespace>/ <code files> test/ phpunit.xml bootstrap.php <module_namespace>/ <test code files> view/ <dir-named-after-module-namespace>/ <dir-named-after-a-controller>/ <.phtml files> Since a module acts as a namespace, the module root directory should be that namespace. This namespace could also include a vendor prefix of sorts. As an example a module centered around \"User\" functionality delivered by Laminas might be named \"LaminasUser\", and this is also what the module root directory will be named.","title":"Basic Module Structure"},{"location":"intro/#bootstrapping-an-application","text":"The Application has seven basic dependencies. configuration , usually an array or object implementing Traversable . ServiceManager instance. EventManager instance, which, by default, is pulled from the ServiceManager , by the service name \"EventManager\". SharedEventManager instance, which, by default, is pulled from the ServiceManager , by the service name \"SharedEventManager\"; this is injected into the EventManager instance, and then pushed into every new EventManager instance created. ModuleManager instance, which, by default, is pulled from the ServiceManager , by the service name \"ModuleManager\". Request instance, which, by default, is pulled from the ServiceManager , by the service name \"Request\". Response instance, which, by default, is pulled from the ServiceManager , by the service name \"Response\". These may be satisfied at instantiation: use Laminas\\EventManager\\EventManager; use Laminas\\EventManager\\SharedEventManager; use Laminas\\Http\\PhpEnvironment; use Laminas\\ModuleManager\\ModuleManager; use Laminas\\Mvc\\Application; use Laminas\\ServiceManager\\ServiceManager; $config = include 'config/application.config.php'; $serviceManager = new ServiceManager(); $serviceManager->setService('SharedEventManager', new SharedEventManager()); $serviceManager->setService('ModuleManager', new ModuleManager($config)); $serviceManager->setService('Request', new PhpEnvironment\\Request()); $serviceManager->setService('Response', new PhpEnvironment\\Response()); $serviceManager->setFactory('EventManager', function ($serviceManager) { return new EventManager($serviceManager->get('SharedEventManager')); }); $serviceManager->setShared('EventManager', false); $application = new Application($config, $serviceManager); Once you've done this, there are two additional actions you can take. The first is to \"bootstrap\" the application. In the default implementation, this does the following: Attaches the default route listener ( Laminas\\Mvc\\RouteListener ). Attaches the middleware dispatch listener ( Laminas\\Mvc\\MiddlewareListener ) (v2.7.0 and up). Attaches the default dispatch listener ( Laminas\\Mvc\\DispatchListener ). Attaches the ViewManager listener ( Laminas\\Mvc\\View\\ViewManager ). Creates the MvcEvent , and injects it with the application, request, and response; it also retrieves the router ( Laminas\\Router\\Http\\TreeRouteStack ) at this time and attaches it to the event. Triggers the \"bootstrap\" event. If you do not want these actions, or want to provide alternatives, you can do so by extending the Application class and/or manually coding what actions you want to occur. The second action you can take with the configured Application is to run() it. Calling this method performs the following: it triggers the \"route\" event, followed by the \"dispatch\" event, and, depending on execution, the \"render\" event When done, it triggers the \"finish\" event, and then returns the response instance. If an error occurs during either the \"route\" or \"dispatch\" event, a \"dispatch.error\" event is triggered as well. This is a lot to remember in order to bootstrap the application; in fact, we haven't covered all the services available by default yet. You can greatly simplify things by using the default ServiceManager configuration shipped with the MVC. use Laminas\\Loader\\AutoloaderFactory; use Laminas\\Mvc\\Service\\ServiceManagerConfig; use Laminas\\ServiceManager\\ServiceManager; // setup autoloader AutoloaderFactory::factory(); // get application stack configuration $configuration = include 'config/application.config.php'; // setup service manager $serviceManager = new ServiceManager(new ServiceManagerConfig()); $serviceManager->setService('ApplicationConfig', $configuration); // load modules -- which will provide services, configuration, and more $serviceManager->get('ModuleManager')->loadModules(); // bootstrap and run application $application = $serviceManager->get('Application'); $application->bootstrap(); $application->run(); You can make this even simpler by using the init() method of the Application . This is a static method for quick and easy initialization of the Application instance. use Laminas\\Loader\\AutoloaderFactory; use Laminas\\Mvc\\Application; use Laminas\\Mvc\\Service\\ServiceManagerConfig; use Laminas\\ServiceManager\\ServiceManager; // setup autoloader AutoloaderFactory::factory(); // get application stack configuration $configuration = include 'config/application.config.php'; // The init() method does something very similar with the previous example. Application::init($configuration)->run(); The init() does the following: Grabs the application configuration and pulls from the service_manager key, creating a ServiceManager instance with it and with the default services shipped with laminas-mvc; Creates a service named ApplicationConfig with the application configuration array; Grabs the ModuleManager service and loads the modules; bootstrap() s the Application and returns its instance.","title":"Bootstrapping an Application"},{"location":"intro/#bootstrapping-a-modular-application","text":"While the previous approach largely works, where does the configuration come from? When we create a modular application, the assumption will be that it's from the modules themselves. How do we get that information and aggregate it, then? The answer is via laminas-modulemanager. This component allows you to specify what modules the application will use; it then locates each module and initializes it. Module classes can tie into various listeners in order to provide configuration, services, listeners, and more to the application. Sounds complicated? It's not.","title":"Bootstrapping a Modular Application"},{"location":"intro/#conclusion","text":"laminas-mvc is incredibly flexible, offering an opt-in, easy to create modular infrastructure, as well as the ability to craft your own application workflows via the ServiceManager and EventManager . The ModuleManager is a lightweight and simple approach to enforcing a modular architecture that encourages clean separation of concerns and code re-use.","title":"Conclusion"},{"location":"middleware/","text":"Dispatching PSR-7 Middleware PSR-7 defines interfaces for HTTP messages, and is now being adopted by many frameworks; Laminas itself offers a parallel microframework targeting PSR-7 with Mezzio . What if you want to dispatch PSR-7 middleware from laminas-mvc? laminas-mvc currently uses laminas-http for its HTTP transport layer, and the objects it defines are not compatible with PSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7 currently. However, starting with version 2.7.0, laminas-mvc offers Laminas\\Mvc\\MiddlewareListener . This dispatch listener listens prior to the default DispatchListener , and executes if the route matches contain a \"middleware\" parameter, and the service that resolves to is callable. When those conditions are met, it uses the PSR-7 bridge to convert the laminas-http request and response objects into PSR-7 instances, and then invokes the middleware. Mapping routes to middleware The first step is to map a route to PSR-7 middleware. This looks like any other routing configuration, with one small change: instead of providing a \"controller\" in the routing defaults, you provide \"middleware\": // Via configuration: return [ 'router' => 'routes' => [ 'home' => [ 'type' => 'literal', 'options' => [ 'route' => '/', 'defaults' => [ 'middleware' => 'Application\\Middleware\\IndexMiddleware', ], ], ], ], ], ]; // Manually: $route = Literal::factory([ 'route' => '/', 'defaults' => [ 'middleware' => 'Application\\Middleware\\IndexMiddleware', ], ]); Middleware may be provided as PHP callables, or as service names. As of 3.1.0 you may also specify an array of middleware, and middleware may be http-interop/http-middleware compatible. Each item in the array must be a PHP callable, service name, or http-middleware instance. These will then be piped into a Laminas\\Stratigility\\MiddlewarePipe instance in the order in which they are present in the array. No action required Unlike action controllers, middleware typically is single purpose, and, as such, does not require a default action parameter. Middleware services In a normal laminas-mvc dispatch cycle, controllers are pulled from a dedicated ControllerManager . Middleware, however, are pulled from the application service manager. Middleware retrieved must be PHP callables. The MiddlewareListener will create an error response if non-callable middleware is indicated. Writing middleware Prior to 3.1.0, when dispatching middleware, the MiddlewareListener calls it with two arguments, the PSR-7 request and response, respectively. As such, your middleware signature should look like the following: namespace Application\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class IndexMiddleware { public function __invoke(ServerRequestInterface $request, ResponseInterface $response) { // do some work } } Starting in 3.1.0, the MiddlewareListener always adds middleware to a Laminas\\Stratigility\\MiddlewarePipe instance, and invokes it as http-interop/http-middleware , passing it a PSR-7 ServerRequestInterface and an http-interop DelegateInterface . As such, ideally your middleware should implement the MiddlewareInterface from http-interop/http-middleware : namespace Application\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class IndexMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // do some work } } Alternately, you may still write callable middleware using the following signature: function (ServerREquestInterface $request, ResponseInterface $response, callable $next) { // do some work } In the above case, the DelegateInterface is decorated as a callable. In all versions, within your middleware, you can pull information from the composed request, and return a response. Routing parameters At the time of the 2.7.0 release, route match parameters were not yet injected into the PSR-7 ServerRequest instance, and thus not available as request attributes. With the 3.0 release, they are pushed into the PSR-7 ServerRequest as attributes, and may thus be fetched using $request->getAttribute($attributeName) . Middleware return values Ideally, your middleware should return a PSR-7 response. When it does, it is converted back to a laminas-http response and returned by the MiddlewareListener , causing the application to short-circuit and return the response immediately. You can, however, return arbitrary values. If you do, the result is pushed into the MvcEvent as the event result, allowing later dispatch listeners to manipulate the results.","title":"Dispatching PSR-7 Middleware"},{"location":"middleware/#dispatching-psr-7-middleware","text":"PSR-7 defines interfaces for HTTP messages, and is now being adopted by many frameworks; Laminas itself offers a parallel microframework targeting PSR-7 with Mezzio . What if you want to dispatch PSR-7 middleware from laminas-mvc? laminas-mvc currently uses laminas-http for its HTTP transport layer, and the objects it defines are not compatible with PSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7 currently. However, starting with version 2.7.0, laminas-mvc offers Laminas\\Mvc\\MiddlewareListener . This dispatch listener listens prior to the default DispatchListener , and executes if the route matches contain a \"middleware\" parameter, and the service that resolves to is callable. When those conditions are met, it uses the PSR-7 bridge to convert the laminas-http request and response objects into PSR-7 instances, and then invokes the middleware.","title":"Dispatching PSR-7 Middleware"},{"location":"middleware/#mapping-routes-to-middleware","text":"The first step is to map a route to PSR-7 middleware. This looks like any other routing configuration, with one small change: instead of providing a \"controller\" in the routing defaults, you provide \"middleware\": // Via configuration: return [ 'router' => 'routes' => [ 'home' => [ 'type' => 'literal', 'options' => [ 'route' => '/', 'defaults' => [ 'middleware' => 'Application\\Middleware\\IndexMiddleware', ], ], ], ], ], ]; // Manually: $route = Literal::factory([ 'route' => '/', 'defaults' => [ 'middleware' => 'Application\\Middleware\\IndexMiddleware', ], ]); Middleware may be provided as PHP callables, or as service names. As of 3.1.0 you may also specify an array of middleware, and middleware may be http-interop/http-middleware compatible. Each item in the array must be a PHP callable, service name, or http-middleware instance. These will then be piped into a Laminas\\Stratigility\\MiddlewarePipe instance in the order in which they are present in the array.","title":"Mapping routes to middleware"},{"location":"middleware/#middleware-services","text":"In a normal laminas-mvc dispatch cycle, controllers are pulled from a dedicated ControllerManager . Middleware, however, are pulled from the application service manager. Middleware retrieved must be PHP callables. The MiddlewareListener will create an error response if non-callable middleware is indicated.","title":"Middleware services"},{"location":"middleware/#writing-middleware","text":"Prior to 3.1.0, when dispatching middleware, the MiddlewareListener calls it with two arguments, the PSR-7 request and response, respectively. As such, your middleware signature should look like the following: namespace Application\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class IndexMiddleware { public function __invoke(ServerRequestInterface $request, ResponseInterface $response) { // do some work } } Starting in 3.1.0, the MiddlewareListener always adds middleware to a Laminas\\Stratigility\\MiddlewarePipe instance, and invokes it as http-interop/http-middleware , passing it a PSR-7 ServerRequestInterface and an http-interop DelegateInterface . As such, ideally your middleware should implement the MiddlewareInterface from http-interop/http-middleware : namespace Application\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class IndexMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // do some work } } Alternately, you may still write callable middleware using the following signature: function (ServerREquestInterface $request, ResponseInterface $response, callable $next) { // do some work } In the above case, the DelegateInterface is decorated as a callable. In all versions, within your middleware, you can pull information from the composed request, and return a response.","title":"Writing middleware"},{"location":"middleware/#middleware-return-values","text":"Ideally, your middleware should return a PSR-7 response. When it does, it is converted back to a laminas-http response and returned by the MiddlewareListener , causing the application to short-circuit and return the response immediately. You can, however, return arbitrary values. If you do, the result is pushed into the MvcEvent as the event result, allowing later dispatch listeners to manipulate the results.","title":"Middleware return values"},{"location":"mvc-event/","text":"The MvcEvent laminas-mvc defines and utilizes a custom Laminas\\EventManager\\Event implementation, Laminas\\Mvc\\MvcEvent . This event is created during Laminas\\Mvc\\Application::bootstrap() and is passed when triggering all application events. Additionally, if your controllers implement the Laminas\\Mvc\\InjectApplicationEventInterface , MvcEvent will be injected into those controllers. The MvcEvent adds accessors and mutators for the following: Application object. Request object. Response object. Router object. RouteMatch object. Result - usually the result of dispatching a controller. ViewModel object, typically representing the layout view model. The methods it defines are: setApplication($application) getApplication() setRequest($request) getRequest() setResponse($response) getResponse() setRouter($router) getRouter() setRouteMatch($routeMatch) getRouteMatch() setResult($result) getResult() setViewModel($viewModel) getViewModel() isError() setError() getError() getController() setController($name) getControllerClass() setControllerClass($class) The Application , Request , Response , Router , and ViewModel are all injected during the bootstrap event. Following the route event, it will be injected also with the RouteMatch object encapsulating the results of routing. Since this object is passed around throughout the MVC, it is a common location for retrieving the results of routing, the router, and the request and response objects. Additionally, we encourage setting the results of execution in the event, to allow event listeners to introspect them and utilize them within their execution. As an example, the results could be passed into a view renderer. Order of events The following events are triggered, in the following order: Name Constant Description bootstrap MvcEvent::EVENT_BOOTSTRAP Bootstrap the application by creating the ViewManager. route MvcEvent::EVENT_ROUTE Perform routing (or route-related actions). dispatch MvcEvent::EVENT_DISPATCH Dispatch the matched route to a controller/action. dispatch.error MvcEvent::EVENT_DISPATCH_ERROR Event triggered in case of a problem during dispatch process (e.g., unknown controller). render MvcEvent::EVENT_RENDER Prepare the data and delegate the rendering to the view layer. render.error MvcEvent::EVENT_RENDER_ERROR Event triggered in case of a problem during the render process (e.g., no renderer found). finish MvcEvent::EVENT_FINISH Perform tasks once everything else is done. The following sections provide more detail on each event. MvcEvent::EVENT_BOOTSTRAP (\"bootstrap\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Triggers Description Laminas\\Mvc\\View\\Http\\ViewManager 10000 onBootstrap none Prepares the view layer (instantiate a Laminas\\Mvc\\View\\Http\\ViewManager ). Triggered By This event is triggered by the following classes: Class In Method Laminas\\Mvc\\Application bootstrap MvcEvent::EVENT_ROUTE (\"route\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Triggers Description Laminas\\Mvc\\ModuleRouteListener 1 onRoute none Determines if the module namespace should be prepended to the controller name. This is the case if the route match contains a parameter key matching the MODULE_NAMESPACE constant. Laminas\\Mvc\\RouteListener 1 onRoute MvcEvent::EVENT_DISPATCH_ERROR (if no route is matched) Tries to match the request to the router and return a RouteMatch object. Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\Application run Uses a short circuit callback that allows halting propagation of the event if an error is raised during routing. MvcEvent::EVENT_DISPATCH (\"dispatch\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console context only The following listeners are only attached in a console context: Class Priority Method Called Description Laminas\\Mvc\\View\\Console\\InjectNamedConsoleParamsListener 1000 injectNamedParams Merge all params (route match params and params in the command), and add them to the Request object. Laminas\\Mvc\\View\\Console\\CreateViewModelListener -80 createViewModelFromArray If the controller action returns an associative array, this listener casts it to a ConsoleModel object. Laminas\\Mvc\\View\\Console\\CreateViewModelListener -80 createViewModelFromString If the controller action returns a string, this listener casts it to a ConsoleModel object. Laminas\\Mvc\\View\\Console\\CreateViewModelListener -80 createViewModelFromNull If the controller action returns null, this listener casts it to a ConsoleModel object. Laminas\\Mvc\\View\\Console\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ConsoleModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminal. HTTP context only The following listeners are only attached in an HTTP context: Class Priority Method Called Description Laminas\\Mvc\\View\\Http\\CreateViewModelListener -80 createViewModelFromArray If the controller action returns an associative array, this listener casts it to a ViewModel object. Laminas\\Mvc\\View\\Http\\CreateViewModelListener -80 createViewModelFromNull If the controller action returns null, this listener casts it to a ViewModel object. Laminas\\Mvc\\View\\Http\\RouteNotFoundStrategy -90 prepareNotFoundViewModel Creates and return a 404 ViewModel . Laminas\\Mvc\\View\\Http\\InjectTemplateListener -90 injectTemplate Injects a template into the view model, if none present. Template name is derived from the controller found in the route match, and, optionally, the action, if present. Laminas\\Mvc\\View\\Http\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. All contexts The following listeners are attached for all contexts (sorted from higher priority to lower priority): Class Priority Method Called Triggers Description Laminas\\Mvc\\MiddlewareListener 1 onDispatch MvcEvent::EVENT_DISPATCH_ERROR (if an exception is raised during dispatch processes) Load and dispatch the matched PSR-7 middleware from the service manager (and throws various exceptions if it does not). Laminas\\Mvc\\DispatchListener 1 onDispatch MvcEvent::EVENT_DISPATCH_ERROR (if an exception is raised during dispatch processes) Load and dispatch the matched controller from the service manager (and throws various exceptions if it does not). Laminas\\Mvc\\AbstractController 1 onDispatch none The onDispatch method of the AbstractController is an abstract method. In AbstractActionController , for instance, it calls the action method. Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\Application run Uses a short circuit callback to halt propagation of the event if an error is raised during routing. Laminas\\Mvc\\Controller\\AbstractController dispatch If a listener returns a Response object, it halts propagation. Note: every AbstractController listens to this event and executes the onDispatch method when it is triggered. MvcEvent::EVENT_DISPATCH_ERROR (\"dispatch.error\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console context only The following listeners are only attached in a console context: Class Priority Method Called Description Laminas\\Mvc\\View\\Console\\RouteNotFoundStrategy 1 handleRouteNotFoundError Detect if an error is a \"route not found\" condition. If a \u201ccontroller not found\u201d or \u201cinvalid controller\u201d error type is encountered, sets the response status code to 404. Laminas\\Mvc\\View\\Console\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model, and sets the status code to 404. Laminas\\Mvc\\View\\Console\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ConsoleModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. HTTP context only The following listeners are only attached in an HTTP context: Class Priority Method Called Description Laminas\\Mvc\\View\\Http\\RouteNotFoundStrategy 1 detectNotFoundError Detect if an error is a 404 condition. If a \u201ccontroller not found\u201d or \u201cinvalid controller\u201d error type is encountered, sets the response status code to 404. Laminas\\Mvc\\View\\Http\\RouteNotFoundStrategy 1 prepareNotFoundViewModel Create and return a 404 view model. Laminas\\Mvc\\View\\Http\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model and set the status code to 404. Laminas\\Mvc\\View\\Http\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. All contexts The following listeners are attached for all contexts: Class Priority Method Called Description Laminas\\Mvc\\DispatchListener 1 reportMonitorEvent Used for monitoring when Zend Server is used. Triggered By Class In Method Laminas\\Mvc\\MiddlewareListener onDispatch Laminas\\Mvc\\DispatchListener onDispatch Laminas\\Mvc\\DispatchListener marshallControllerNotFoundEvent Laminas\\Mvc\\DispatchListener marshallBadControllerEvent MvcEvent::EVENT_RENDER (\"render\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console context only The following listeners are only attached in a console context: Class Priority Method Called Description Laminas\\Mvc\\View\\Console\\DefaultRenderingStrategy -10000 render Render the view. HTTP context only The following listeners are only attached in an HTTP context: Class Priority Method Called Description Laminas\\Mvc\\View\\Http\\DefaultRenderingStrategy -10000 render Render the view. Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\Application completeRequest This event is triggered just before the MvcEvent::FINISH event. MvcEvent::EVENT_RENDER_ERROR (\"render.error\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console context only The following listeners are only attached in a console context: Class Priority Method Called Description Laminas\\Mvc\\View\\Console\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model and set the status code to 404. Laminas\\Mvc\\View\\Console\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ConsoleModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. HTTP context only The following listeners are only attached in an HTTP context: Class Priority Method Called Description Laminas\\Mvc\\View\\Http\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model and set the status code to 404. Laminas\\Mvc\\View\\Http\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. Laminas\\Mvc\\View\\Http\\DefaultRenderingStrategy -10000 render Render the view Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\View\\Http\\DefaultRenderingStrategy render This event is triggered if an exception is raised during rendering. MvcEvent::EVENT_FINISH (\"finish\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Description Laminas\\Mvc\\SendResponseListener -10000 sendResponse Triggers the SendResponseEvent in order to prepare the response (see the next chapter for more information about SendResponseEvent ). Triggered By This event is triggered by the following classes: Class In Method Description Laminas\\Mvc\\Application run This event is triggered once the MvcEvent::ROUTE event returns a correct ResponseInterface . Laminas\\Mvc\\Application run This event is triggered once the MvcEvent::DISPATCH event returns a correct ResponseInterface . Laminas\\Mvc\\Application completeRequest This event is triggered after MvcEvent::RENDER (at this point, the view is already rendered).","title":"The MVC Event"},{"location":"mvc-event/#the-mvcevent","text":"laminas-mvc defines and utilizes a custom Laminas\\EventManager\\Event implementation, Laminas\\Mvc\\MvcEvent . This event is created during Laminas\\Mvc\\Application::bootstrap() and is passed when triggering all application events. Additionally, if your controllers implement the Laminas\\Mvc\\InjectApplicationEventInterface , MvcEvent will be injected into those controllers. The MvcEvent adds accessors and mutators for the following: Application object. Request object. Response object. Router object. RouteMatch object. Result - usually the result of dispatching a controller. ViewModel object, typically representing the layout view model. The methods it defines are: setApplication($application) getApplication() setRequest($request) getRequest() setResponse($response) getResponse() setRouter($router) getRouter() setRouteMatch($routeMatch) getRouteMatch() setResult($result) getResult() setViewModel($viewModel) getViewModel() isError() setError() getError() getController() setController($name) getControllerClass() setControllerClass($class) The Application , Request , Response , Router , and ViewModel are all injected during the bootstrap event. Following the route event, it will be injected also with the RouteMatch object encapsulating the results of routing. Since this object is passed around throughout the MVC, it is a common location for retrieving the results of routing, the router, and the request and response objects. Additionally, we encourage setting the results of execution in the event, to allow event listeners to introspect them and utilize them within their execution. As an example, the results could be passed into a view renderer.","title":"The MvcEvent"},{"location":"mvc-event/#order-of-events","text":"The following events are triggered, in the following order: Name Constant Description bootstrap MvcEvent::EVENT_BOOTSTRAP Bootstrap the application by creating the ViewManager. route MvcEvent::EVENT_ROUTE Perform routing (or route-related actions). dispatch MvcEvent::EVENT_DISPATCH Dispatch the matched route to a controller/action. dispatch.error MvcEvent::EVENT_DISPATCH_ERROR Event triggered in case of a problem during dispatch process (e.g., unknown controller). render MvcEvent::EVENT_RENDER Prepare the data and delegate the rendering to the view layer. render.error MvcEvent::EVENT_RENDER_ERROR Event triggered in case of a problem during the render process (e.g., no renderer found). finish MvcEvent::EVENT_FINISH Perform tasks once everything else is done. The following sections provide more detail on each event.","title":"Order of events"},{"location":"mvc-event/#mvceventevent_bootstrap-bootstrap","text":"","title":"MvcEvent::EVENT_BOOTSTRAP (\"bootstrap\")"},{"location":"mvc-event/#mvceventevent_route-route","text":"","title":"MvcEvent::EVENT_ROUTE (\"route\")"},{"location":"mvc-event/#mvceventevent_dispatch-dispatch","text":"","title":"MvcEvent::EVENT_DISPATCH (\"dispatch\")"},{"location":"mvc-event/#mvceventevent_dispatch_error-dispatcherror","text":"","title":"MvcEvent::EVENT_DISPATCH_ERROR (\"dispatch.error\")"},{"location":"mvc-event/#mvceventevent_render-render","text":"","title":"MvcEvent::EVENT_RENDER (\"render\")"},{"location":"mvc-event/#mvceventevent_render_error-rendererror","text":"","title":"MvcEvent::EVENT_RENDER_ERROR (\"render.error\")"},{"location":"mvc-event/#mvceventevent_finish-finish","text":"","title":"MvcEvent::EVENT_FINISH (\"finish\")"},{"location":"plugins/","text":"Controller Plugins When using any of the abstract controller implementations shipped with laminas-mvc, or if you implement the setPluginManager method in your custom controllers, you have access to a number of pre-built plugins. Additionally, you can register your own custom plugins with the manager. The built-in plugins are: Laminas\\Mvc\\Controller\\Plugin\\AcceptableViewModelSelector Laminas\\Mvc\\Controller\\Plugin\\Forward Laminas\\Mvc\\Controller\\Plugin\\Layout Laminas\\Mvc\\Controller\\Plugin\\Params Laminas\\Mvc\\Controller\\Plugin\\Redirect Laminas\\Mvc\\Controller\\Plugin\\Url If your controller implements the setPluginManager() , getPluginManager() and plugin() methods, you can access these using their shortname via the plugin() method: $plugin = $this->plugin('url'); For an extra layer of convenience, this shipped abstract controller implementations have __call() methods defined that allow you to retrieve plugins via method calls: $plugin = $this->url(); AcceptableViewModelSelector Plugin The AcceptableViewModelSelector is a helper that can be used to select an appropriate view model based on user defined criteria will be tested against the Accept header in the request. As an example: use Laminas\\Mvc\\Controller\\AbstractActionController; class SomeController extends AbstractActionController { protected $acceptCriteria = [ \\Laminas\\View\\Model\\ViewModel::class => [ 'text/html', 'application/xhtml+xml', ], \\Laminas\\View\\Model\\JsonModel::class => [ 'application/json', 'application/javascript', ], \\Laminas\\View\\Model\\FeedModel::class => [ 'application/rss+xml', 'application/atom+xml', ], ]; public function apiAction() { $viewModel = $this->acceptableViewModelSelector($this->acceptCriteria); // Potentially vary execution based on model returned if ($viewModel instanceof \\Laminas\\View\\Model\\JsonModel) { // ... } } } The above would return a standard Laminas\\View\\Model\\ViewModel instance if no criterias are met, and the specified view model types if a specific criteria is met. Rules are matched in order, with the first match \"winning\". Make sure to put your fallback view model first as a fallback for unknown content types or */* . Browsers are sending */* as last content type of the Accept header so you have to define every acceptable view model and their content type. Forward Plugin Occasionally, you may want to dispatch additional controllers from within the matched controller. For example, you might use this approach to build up \"widgetized\" content. The Forward plugin helps enable this. For the Forward plugin to work, the controller calling it must be ServiceLocatorAware ; otherwise, the plugin will be unable to retrieve a configured and injected instance of the requested controller. The plugin exposes a single method, dispatch() , which takes two arguments: $name , the name of the controller to invoke. This may be either the fully qualified class name, or an alias defined and recognized by the ServiceManager instance attached to the invoking controller. $params is an optional array of parameters with which to seed a RouteMatch object for purposes of this specific request. Meaning the parameters will be matched by their key to the routing identifiers in the config (otherwise non-matching keys are ignored) Forward returns the results of dispatching the requested controller; it is up to the developer to determine what, if anything, to do with those results. One recommendation is to aggregate them in any return value from the invoking controller. As an example: $foo = $this->forward()->dispatch('foo', ['action' => 'process']); return [ 'somekey' => $somevalue, 'foo' => $foo, ]; Layout Plugin The Layout plugin allows changing layout templates from within controller actions. It exposes a single method, setTemplate() , which takes one argument, $template , the name of the template to set. As an example: $this->layout()->setTemplate('layout/newlayout'); It also implements the __invoke magic method, which allows calling the plugin as a method call: $this->layout('layout/newlayout'); Params Plugin The Params plugin allows accessing parameters in actions from different sources. It exposes several methods, one for each parameter source: fromFiles(string $name = null, mixed $default = null): array|ArrayAccess|null : For retrieving all or one single file . If $name is null, all files will be returned. fromHeader(string $header = null, mixed $default = null) : null|Laminas\\Http\\Header\\HeaderInterface : For retrieving all or one single header parameter. If $header is null, all header parameters will be returned. fromPost(string $param = null, mixed $default = null) : mixed : For retrieving all or one single post parameter. If $param is null, all post parameters will be returned. fromQuery(string $param = null, mixed $default = null) : mixed : For retrieving all or one single query parameter. If $param is null, all query parameters will be returned. fromRoute(string $param = null, mixed $default = null) : mixed : For retrieving all or one single route parameter. If $param is null, all route parameters will be returned. The plugin also implements the __invoke magic method, providing a shortcut for invoking the fromRoute method: $this->params()->fromRoute('param', $default); // or $this->params('param', $default); Redirect Plugin Redirections are quite common operations within applications. If done manually, you will need to do the following steps: Assemble a url using the router. Create and inject a \"Location\" header into the Response object, pointing to the assembled URL. Set the status code of the Response object to one of the 3xx HTTP statuses. The Redirect plugin does this work for you. It offers three methods: toRoute(string $route = null, array $params = array(), array $options = array(), boolean $reuseMatchedParams = false) : Laminas\\Http\\Response : Redirects to a named route, using the provided $params and $options to assembled the URL. toUrl(string $url) : Laminas\\Http\\Response : Simply redirects to the given URL. refresh() : Laminas\\Http\\Response : Refresh to current route. In each case, the Response object is returned. If you return this immediately, you can effectively short-circuit execution of the request. Requires MvcEvent This plugin requires that the controller invoking it implements InjectApplicationEventInterface , and thus has an MvcEvent composed, as it retrieves the router from the event object. As an example: return $this->redirect()->toRoute('login-success'); Url Plugin You may need to generate URLs from route definitions within your controllers; for example, to seed the view, generate headers, etc. While the MvcEvent object composes the router, doing so manually would require this workflow: $router = $this->getEvent()->getRouter(); $url = $router->assemble($params, ['name' => 'route-name']); The Url helper makes this slightly more convenient: $url = $this->url()->fromRoute('route-name', $params); The fromRoute() method is the only public method defined, and is used to generate a URL string from the provided parameters. It has the following signature: fromRoute(string $route = null, array $params = [], array $options = [], bool $reuseMatchedParams = false): string , where: $name : the name of the route to use for URL generation. $params : Any parameter substitutions to use with the named route. $options : Options used by the router when generating the URL (e.g., force_canonical , query , etc.). $reuseMatchedParams : Whether or not to use route match parameters from the current URL when generating the new URL. This will only affect cases where the specified $name matches the currently matched route; the default is true . Requires MvcEvent This plugin requires that the controller invoking it implements InjectApplicationEventInterface , and thus has an MvcEvent composed, as it retrieves the router from the event object.","title":"Controller Plugins"},{"location":"plugins/#controller-plugins","text":"When using any of the abstract controller implementations shipped with laminas-mvc, or if you implement the setPluginManager method in your custom controllers, you have access to a number of pre-built plugins. Additionally, you can register your own custom plugins with the manager. The built-in plugins are: Laminas\\Mvc\\Controller\\Plugin\\AcceptableViewModelSelector Laminas\\Mvc\\Controller\\Plugin\\Forward Laminas\\Mvc\\Controller\\Plugin\\Layout Laminas\\Mvc\\Controller\\Plugin\\Params Laminas\\Mvc\\Controller\\Plugin\\Redirect Laminas\\Mvc\\Controller\\Plugin\\Url If your controller implements the setPluginManager() , getPluginManager() and plugin() methods, you can access these using their shortname via the plugin() method: $plugin = $this->plugin('url'); For an extra layer of convenience, this shipped abstract controller implementations have __call() methods defined that allow you to retrieve plugins via method calls: $plugin = $this->url();","title":"Controller Plugins"},{"location":"plugins/#acceptableviewmodelselector-plugin","text":"The AcceptableViewModelSelector is a helper that can be used to select an appropriate view model based on user defined criteria will be tested against the Accept header in the request. As an example: use Laminas\\Mvc\\Controller\\AbstractActionController; class SomeController extends AbstractActionController { protected $acceptCriteria = [ \\Laminas\\View\\Model\\ViewModel::class => [ 'text/html', 'application/xhtml+xml', ], \\Laminas\\View\\Model\\JsonModel::class => [ 'application/json', 'application/javascript', ], \\Laminas\\View\\Model\\FeedModel::class => [ 'application/rss+xml', 'application/atom+xml', ], ]; public function apiAction() { $viewModel = $this->acceptableViewModelSelector($this->acceptCriteria); // Potentially vary execution based on model returned if ($viewModel instanceof \\Laminas\\View\\Model\\JsonModel) { // ... } } } The above would return a standard Laminas\\View\\Model\\ViewModel instance if no criterias are met, and the specified view model types if a specific criteria is met. Rules are matched in order, with the first match \"winning\". Make sure to put your fallback view model first as a fallback for unknown content types or */* . Browsers are sending */* as last content type of the Accept header so you have to define every acceptable view model and their content type.","title":"AcceptableViewModelSelector Plugin"},{"location":"plugins/#forward-plugin","text":"Occasionally, you may want to dispatch additional controllers from within the matched controller. For example, you might use this approach to build up \"widgetized\" content. The Forward plugin helps enable this. For the Forward plugin to work, the controller calling it must be ServiceLocatorAware ; otherwise, the plugin will be unable to retrieve a configured and injected instance of the requested controller. The plugin exposes a single method, dispatch() , which takes two arguments: $name , the name of the controller to invoke. This may be either the fully qualified class name, or an alias defined and recognized by the ServiceManager instance attached to the invoking controller. $params is an optional array of parameters with which to seed a RouteMatch object for purposes of this specific request. Meaning the parameters will be matched by their key to the routing identifiers in the config (otherwise non-matching keys are ignored) Forward returns the results of dispatching the requested controller; it is up to the developer to determine what, if anything, to do with those results. One recommendation is to aggregate them in any return value from the invoking controller. As an example: $foo = $this->forward()->dispatch('foo', ['action' => 'process']); return [ 'somekey' => $somevalue, 'foo' => $foo, ];","title":"Forward Plugin"},{"location":"plugins/#layout-plugin","text":"The Layout plugin allows changing layout templates from within controller actions. It exposes a single method, setTemplate() , which takes one argument, $template , the name of the template to set. As an example: $this->layout()->setTemplate('layout/newlayout'); It also implements the __invoke magic method, which allows calling the plugin as a method call: $this->layout('layout/newlayout');","title":"Layout Plugin"},{"location":"plugins/#params-plugin","text":"The Params plugin allows accessing parameters in actions from different sources. It exposes several methods, one for each parameter source: fromFiles(string $name = null, mixed $default = null): array|ArrayAccess|null : For retrieving all or one single file . If $name is null, all files will be returned. fromHeader(string $header = null, mixed $default = null) : null|Laminas\\Http\\Header\\HeaderInterface : For retrieving all or one single header parameter. If $header is null, all header parameters will be returned. fromPost(string $param = null, mixed $default = null) : mixed : For retrieving all or one single post parameter. If $param is null, all post parameters will be returned. fromQuery(string $param = null, mixed $default = null) : mixed : For retrieving all or one single query parameter. If $param is null, all query parameters will be returned. fromRoute(string $param = null, mixed $default = null) : mixed : For retrieving all or one single route parameter. If $param is null, all route parameters will be returned. The plugin also implements the __invoke magic method, providing a shortcut for invoking the fromRoute method: $this->params()->fromRoute('param', $default); // or $this->params('param', $default);","title":"Params Plugin"},{"location":"plugins/#redirect-plugin","text":"Redirections are quite common operations within applications. If done manually, you will need to do the following steps: Assemble a url using the router. Create and inject a \"Location\" header into the Response object, pointing to the assembled URL. Set the status code of the Response object to one of the 3xx HTTP statuses. The Redirect plugin does this work for you. It offers three methods: toRoute(string $route = null, array $params = array(), array $options = array(), boolean $reuseMatchedParams = false) : Laminas\\Http\\Response : Redirects to a named route, using the provided $params and $options to assembled the URL. toUrl(string $url) : Laminas\\Http\\Response : Simply redirects to the given URL. refresh() : Laminas\\Http\\Response : Refresh to current route. In each case, the Response object is returned. If you return this immediately, you can effectively short-circuit execution of the request.","title":"Redirect Plugin"},{"location":"plugins/#url-plugin","text":"You may need to generate URLs from route definitions within your controllers; for example, to seed the view, generate headers, etc. While the MvcEvent object composes the router, doing so manually would require this workflow: $router = $this->getEvent()->getRouter(); $url = $router->assemble($params, ['name' => 'route-name']); The Url helper makes this slightly more convenient: $url = $this->url()->fromRoute('route-name', $params); The fromRoute() method is the only public method defined, and is used to generate a URL string from the provided parameters. It has the following signature: fromRoute(string $route = null, array $params = [], array $options = [], bool $reuseMatchedParams = false): string , where: $name : the name of the route to use for URL generation. $params : Any parameter substitutions to use with the named route. $options : Options used by the router when generating the URL (e.g., force_canonical , query , etc.). $reuseMatchedParams : Whether or not to use route match parameters from the current URL when generating the new URL. This will only affect cases where the specified $name matches the currently matched route; the default is true .","title":"Url Plugin"},{"location":"quick-start/","text":"Quick Start Now that you have basic knowledge of applications, modules, and how they are each structured, we'll show you the easy way to get started. Install the Laminas MVC Skeleton Application The easiest way to get started is to install the skeleton application via Composer. If you have not yet done so, install Composer . Once you have, use the create-project command to create a new application: $ composer create-project -sdev laminas/laminas-mvc-skeleton my-application Create a New Module By default, one module is provided with the laminas-mvc-skeleton , named \"Application\". It provides a controller to handle the \"home\" page of the application, the layout template, and templates for 404 and error pages. Typically, you will not need to touch this other than to provide an alternate entry page for your site and/or alternate error page. Additional functionality will be provided by creating new modules. To get you started with modules, we recommend using the LaminasSkeletonModule as a base. Download it from here: LaminasSkeletonModule zip package LaminasSkeletonModule tarball Deflate the package, and rename the directory \"LaminasSkeletonModule\" to reflect the name of the new module you want to create; when done, move the module into your new project's module/ directory. At this point, it's time to create some functionality. Update the Module Class Let's update the Module class. We'll want to make sure the namespace is correct, configuration is enabled and returned, and that we setup autoloading on initialization. Since we're actively working on this module, the class list will be in flux; we probably want to be pretty lenient in our autoloading approach, so let's keep it flexible by using the StandardAutoloader . Let's begin. First, let's have autoload_classmap.php return an empty array: <?php // autoload_classmap.php return array(); We'll also edit our config/module.config.php file to read as follows: return array( 'view_manager' => array( 'template_path_stack' => array( '<module-name>' => __DIR__ . '/../view' ), ), ); Fill in module-name with a lowercased, dash-separated version of your module name; e.g., \"LaminasUser\" would become \"laminas-user\". Next, edit the namespace declaration of the Module.php file. Replace the following line: namespace LaminasSkeletonModule; with the namespace you want to use for your application. Next, rename the directory src/LaminasSkeletonModule to src/<YourModuleName> , and the directory view/laminas-skeleton-module to src/<your-module-name> . At this point, you now have your module configured properly. Let's create a controller! Create a Controller Controllers are objects that implement Laminas\\Stdlib\\DispatchableInterface . This means they need to implement a dispatch() method that takes minimally a Request object as an argument. In practice, though, this would mean writing logic to branch based on matched routing within every controller. As such, we've created several base controller classes for you to start with: Laminas\\Mvc\\Controller\\AbstractActionController allows routes to match an \"action\". When matched, a method named after the action will be called by the controller. As an example, if you had a route that returned \"foo\" for the \"action\" key, the \"fooAction\" method would be invoked. Laminas\\Mvc\\Controller\\AbstractRestfulController introspects the Request to determine what HTTP method was used, and calls a method according to that. GET will call either the getList() method, or, if an \"id\" was matched during routing, the get() method (with that identifier value). POST will call the create() method, passing in the $_POST values. PUT expects an \"id\" to be matched during routing, and will call the update() method, passing in the identifier, and any data found in the raw post body. DELETE expects an \"id\" to be matched during routing, and will call the delete() method. Laminas\\Mvc\\Console\\Controller\\AbstractConsoleController extends from AbstractActionController , but provides methods for retrieving the Laminas\\Console\\Adapter\\AdapterInterface instance, and ensuring that execution fails in non-console environments. For version 3, the integration component laminas-mvc-console must be installed. It can be done via Composer: `bash composer require laminas/laminas-mvc-console If you are not using the component installer, you will need to add this component as a module . To get started, we'll create a \"hello world\"-style controller, with a single action. First, create the file HelloController.php in the directory src/<module name>/Controller . Edit it in your favorite text editor or IDE, and insert the following contents: <?php namespace <module name>\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; class HelloController extends AbstractActionController { public function worldAction() { $message = $this->params()->fromQuery('message', 'foo'); return new ViewModel(['message' => $message]); } } So, what are we doing here? We're creating an action controller. We're defining an action, \"world\". We're pulling a message from the query parameters (yes, this is a superbly bad idea in production! Always sanitize your inputs!). We're returning a ViewModel with an array of values to be processed later. We return a ViewModel . The view layer will use this when rendering the view, pulling variables and the template name from it. By default, you can omit the template name, and it will resolve to \"lowercase-module-name/lowercase-controller-name/lowercase-action-name\". However, you can override this to specify something different by calling setTemplate() on the ViewModel instance. Typically, templates will resolve to files with a \".phtml\" suffix in your module's view directory. So, with that in mind, let's create a view script. Create a View Script Create the directory view/<module-name>/hello . Inside that directory, create a file named world.phtml . Inside that, paste in the following: <h1>Greetings!</h1> <p>You said \"<?php echo $this->escapeHtml($message) ?>\".</p> That's it. Save the file. Escaping output What is the method escapeHtml() ? It's actually a view helper , and it's designed to help mitigate XSS attacks. Never trust user input; if you are at all uncertain about the source of a given variable in your view script, escape it using one of the provided escape view helpers depending on the type of data you have. View scripts for module names with subnamespaces As per PSR-0, modules should be named following the rule: <Vendor Name>\\<Namespace>\\* . Since version 3.0, the default template name resolver uses fully qualified controller class names, stripping only the \\Controller\\\\ subnamespace, if present. For example, AwesomeMe\\MyModule\\Controller\\HelloWorldController resolves to the template name awesome-me/my-module/hello-world via the following configuration: 'view_manager' => array( 'controller_map' => array( 'AwesomeMe\\MyModule' => true, ), ), (In v2 releases, the default was to strip subnamespaces, but optional mapping rules allowed whitelisting namespaces in module configuration to enable current resolver behavior. See the migration guide for more details.) Create a Route Now that we have a controller and a view script, we need to create a route to it. Default routing LaminasSkeletonModule ships with a \"default route\" that will likely get you to this action. That route is defined roughly as /{module}/{controller}/{action} , which means that the path /laminas-user/hello/world will map to LaminasUser\\Controller\\HelloController::worldAction() (assuming the module name were LaminasUser ). We're going to create an explicit route in this example, as creating explicit routes is a recommended practice. The application will look for a Laminas\\Router\\RouteStackInterface instance to setup routing. The default generated router is a Laminas\\Router\\Http\\TreeRouteStack . To use the \"default route\" functionality, you will need to edit the shipped routing definition in the module's config/module.config.php , and replace: /module-specific-root with a module-specific root path. LaminasSkeletonModule\\Controller with <YourModuleName>\\Controller . Additionally, we need to tell the application we have a controller: // module.config.php return [ 'controllers' => [ 'invokables' => [ '<module-namespace>\\Controller\\Index' => '<module-namespace>\\Controller\\IndexController', // Do similar for each other controller in your module ], ], // ... other configuration ... ]; Controller services We inform the application about controllers we expect to have in the application. This is to prevent somebody requesting any service the ServiceManager knows about in an attempt to break the application. The dispatcher uses a special, scoped container that will only pull controllers that are specifically registered with it, either as invokable classes or via factories. Open your config/module.config.php file, and modify it to add to the \"routes\" and \"controller\" parameters so it reads as follows: return [ 'router' => [ 'routes' => [ '<module name>-hello-world' => [ 'type' => 'Literal', 'options' => [ 'route' => '/hello/world', 'defaults' => [ 'controller' => '<module name>\\Controller\\Hello', 'action' => 'world', ], ], ], ], ], 'controllers' => [ 'invokables' => [ '<module namespace>\\Controller\\Hello' => '<module namespace>\\Controller\\HelloController', ], ], // ... other configuration ... ]; Tell the Application About our Module One problem: we haven't told our application about our new module! By default, modules are not utilized unless we tell the module manager about them. As such, we need to notify the application about them. Remember the config/application.config.php file? Let's modify it to add our new module. Once done, it should read as follows: <?php return array( 'modules' => array( 'Application', '<module namespace>', ), 'module_listener_options' => array( 'module_paths' => array( './module', './vendor', ), ), ); Replace <module namespace> with the namespace of your module. Test it Out! Now we can test things out! Create a new vhost pointing its document root to the public directory of your application, and fire it up in a browser. You should see the default homepage template of laminas-mvc-skeleton . Now alter the location in your URL to append the path \"/hello/world\", and load the page. You should now get the following content: <h1>Greetings!</h1> <p>You said \"foo\".</p> Now alter the location to append \"?message=bar\" and load the page. You should now get: <h1>Greetings!</h1> <p>You said \"bar\".</p> Congratulations! You've created your first Laminas MVC module!","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"Now that you have basic knowledge of applications, modules, and how they are each structured, we'll show you the easy way to get started.","title":"Quick Start"},{"location":"quick-start/#install-the-laminas-mvc-skeleton-application","text":"The easiest way to get started is to install the skeleton application via Composer. If you have not yet done so, install Composer . Once you have, use the create-project command to create a new application: $ composer create-project -sdev laminas/laminas-mvc-skeleton my-application","title":"Install the Laminas MVC Skeleton Application"},{"location":"quick-start/#create-a-new-module","text":"By default, one module is provided with the laminas-mvc-skeleton , named \"Application\". It provides a controller to handle the \"home\" page of the application, the layout template, and templates for 404 and error pages. Typically, you will not need to touch this other than to provide an alternate entry page for your site and/or alternate error page. Additional functionality will be provided by creating new modules. To get you started with modules, we recommend using the LaminasSkeletonModule as a base. Download it from here: LaminasSkeletonModule zip package LaminasSkeletonModule tarball Deflate the package, and rename the directory \"LaminasSkeletonModule\" to reflect the name of the new module you want to create; when done, move the module into your new project's module/ directory. At this point, it's time to create some functionality.","title":"Create a New Module"},{"location":"quick-start/#update-the-module-class","text":"Let's update the Module class. We'll want to make sure the namespace is correct, configuration is enabled and returned, and that we setup autoloading on initialization. Since we're actively working on this module, the class list will be in flux; we probably want to be pretty lenient in our autoloading approach, so let's keep it flexible by using the StandardAutoloader . Let's begin. First, let's have autoload_classmap.php return an empty array: <?php // autoload_classmap.php return array(); We'll also edit our config/module.config.php file to read as follows: return array( 'view_manager' => array( 'template_path_stack' => array( '<module-name>' => __DIR__ . '/../view' ), ), ); Fill in module-name with a lowercased, dash-separated version of your module name; e.g., \"LaminasUser\" would become \"laminas-user\". Next, edit the namespace declaration of the Module.php file. Replace the following line: namespace LaminasSkeletonModule; with the namespace you want to use for your application. Next, rename the directory src/LaminasSkeletonModule to src/<YourModuleName> , and the directory view/laminas-skeleton-module to src/<your-module-name> . At this point, you now have your module configured properly. Let's create a controller!","title":"Update the Module Class"},{"location":"quick-start/#create-a-controller","text":"Controllers are objects that implement Laminas\\Stdlib\\DispatchableInterface . This means they need to implement a dispatch() method that takes minimally a Request object as an argument. In practice, though, this would mean writing logic to branch based on matched routing within every controller. As such, we've created several base controller classes for you to start with: Laminas\\Mvc\\Controller\\AbstractActionController allows routes to match an \"action\". When matched, a method named after the action will be called by the controller. As an example, if you had a route that returned \"foo\" for the \"action\" key, the \"fooAction\" method would be invoked. Laminas\\Mvc\\Controller\\AbstractRestfulController introspects the Request to determine what HTTP method was used, and calls a method according to that. GET will call either the getList() method, or, if an \"id\" was matched during routing, the get() method (with that identifier value). POST will call the create() method, passing in the $_POST values. PUT expects an \"id\" to be matched during routing, and will call the update() method, passing in the identifier, and any data found in the raw post body. DELETE expects an \"id\" to be matched during routing, and will call the delete() method. Laminas\\Mvc\\Console\\Controller\\AbstractConsoleController extends from AbstractActionController , but provides methods for retrieving the Laminas\\Console\\Adapter\\AdapterInterface instance, and ensuring that execution fails in non-console environments. For version 3, the integration component laminas-mvc-console must be installed. It can be done via Composer: `bash composer require laminas/laminas-mvc-console If you are not using the component installer, you will need to add this component as a module . To get started, we'll create a \"hello world\"-style controller, with a single action. First, create the file HelloController.php in the directory src/<module name>/Controller . Edit it in your favorite text editor or IDE, and insert the following contents: <?php namespace <module name>\\Controller; use Laminas\\Mvc\\Controller\\AbstractActionController; use Laminas\\View\\Model\\ViewModel; class HelloController extends AbstractActionController { public function worldAction() { $message = $this->params()->fromQuery('message', 'foo'); return new ViewModel(['message' => $message]); } } So, what are we doing here? We're creating an action controller. We're defining an action, \"world\". We're pulling a message from the query parameters (yes, this is a superbly bad idea in production! Always sanitize your inputs!). We're returning a ViewModel with an array of values to be processed later. We return a ViewModel . The view layer will use this when rendering the view, pulling variables and the template name from it. By default, you can omit the template name, and it will resolve to \"lowercase-module-name/lowercase-controller-name/lowercase-action-name\". However, you can override this to specify something different by calling setTemplate() on the ViewModel instance. Typically, templates will resolve to files with a \".phtml\" suffix in your module's view directory. So, with that in mind, let's create a view script.","title":"Create a Controller"},{"location":"quick-start/#create-a-view-script","text":"Create the directory view/<module-name>/hello . Inside that directory, create a file named world.phtml . Inside that, paste in the following: <h1>Greetings!</h1> <p>You said \"<?php echo $this->escapeHtml($message) ?>\".</p> That's it. Save the file.","title":"Create a View Script"},{"location":"quick-start/#view-scripts-for-module-names-with-subnamespaces","text":"As per PSR-0, modules should be named following the rule: <Vendor Name>\\<Namespace>\\* . Since version 3.0, the default template name resolver uses fully qualified controller class names, stripping only the \\Controller\\\\ subnamespace, if present. For example, AwesomeMe\\MyModule\\Controller\\HelloWorldController resolves to the template name awesome-me/my-module/hello-world via the following configuration: 'view_manager' => array( 'controller_map' => array( 'AwesomeMe\\MyModule' => true, ), ), (In v2 releases, the default was to strip subnamespaces, but optional mapping rules allowed whitelisting namespaces in module configuration to enable current resolver behavior. See the migration guide for more details.)","title":"View scripts for module names with subnamespaces"},{"location":"quick-start/#create-a-route","text":"Now that we have a controller and a view script, we need to create a route to it.","title":"Create a Route"},{"location":"quick-start/#tell-the-application-about-our-module","text":"One problem: we haven't told our application about our new module! By default, modules are not utilized unless we tell the module manager about them. As such, we need to notify the application about them. Remember the config/application.config.php file? Let's modify it to add our new module. Once done, it should read as follows: <?php return array( 'modules' => array( 'Application', '<module namespace>', ), 'module_listener_options' => array( 'module_paths' => array( './module', './vendor', ), ), ); Replace <module namespace> with the namespace of your module.","title":"Tell the Application About our Module"},{"location":"quick-start/#test-it-out","text":"Now we can test things out! Create a new vhost pointing its document root to the public directory of your application, and fire it up in a browser. You should see the default homepage template of laminas-mvc-skeleton . Now alter the location in your URL to append the path \"/hello/world\", and load the page. You should now get the following content: <h1>Greetings!</h1> <p>You said \"foo\".</p> Now alter the location to append \"?message=bar\" and load the page. You should now get: <h1>Greetings!</h1> <p>You said \"bar\".</p> Congratulations! You've created your first Laminas MVC module!","title":"Test it Out!"},{"location":"routing/","text":"Routing Routing is the act of matching a request to a given controller. Typically, routing will examine the request URI, and attempt to match the URI path segment against provided constraints. If the constraints match, a set of \"matches\" are returned, one of which should be the controller name to execute. Routing can utilize other portions of the request URI or environment as well. For example, the host or scheme, query parameters, headers, request method, and more. The base unit of routing is a Route : namespace Laminas\\Router; use Laminas\\Stdlib\\RequestInterface as Request; interface RouteInterface { public static function factory(array $options = []); public function match(Request $request); public function assemble(array $params = [], array $options = []); } A Route accepts a Request , and determines if it matches. If so, it returns a RouteMatch object: namespace Laminas\\Router; class RouteMatch { public function __construct(array $params); public function setMatchedRouteName($name); public function getMatchedRouteName(); public function setParam($name, $value); public function getParams(); public function getParam($name, $default = null); } Typically, when a Route matches, it will define one or more parameters. These are passed into the RouteMatch , and objects may query the RouteMatch for their values. $id = $routeMatch->getParam('id', false); if (! $id) { throw new Exception('Required identifier is missing!'); } $entity = $resource->get($id); Usually you will have multiple routes you wish to test against. In order to facilitate this, you will use a route aggregate, usually implementing RouteStack : namespace Laminas\\Router; interface RouteStackInterface extends RouteInterface { public function addRoute($name, $route, $priority = null); public function addRoutes(array $routes); public function removeRoute($name); public function setRoutes(array $routes); } Routes will be queried in a LIFO order, and hence the reason behind the name RouteStack . laminas-mvc provides two implementations of this interface, SimpleRouteStack and TreeRouteStack . In each, you register routes either one at a time using addRoute() , or in bulk using addRoutes() . // One at a time: $route = Literal::factory([ 'route' => '/foo', 'defaults' => [ 'controller' => 'foo-index', 'action' => 'index', ], ]); $router->addRoute('foo', $route); // In bulk: $router->addRoutes([ // using already instantiated routes: 'foo' => $route, // providing configuration to allow lazy-loading routes: 'bar' => [ 'type' => 'literal', 'options' => [ 'route' => '/bar', 'defaults' => [ 'controller' => 'bar-index', 'action' => 'index', ], ], ], ]); Router Types Two routers are provided, the SimpleRouteStack and TreeRouteStack . Each works with the above interface, but utilize slightly different options and execution paths. By default, the laminas-mvc uses the TreeRouteStack as the router. SimpleRouteStack This router takes individual routes that provide their full matching logic in one go, and loops through them in LIFO order until a match is found. As such, routes that will match most often should be registered last, and least common routes first. Additionally, you will need to ensure that routes that potentially overlap are registered such that the most specific match will match first (i.e., register later). Alternatively, you can set priorities by giving the priority as third parameter to the addRoute() method, specifying the priority in the route specifications or setting the priority property within a route instance before adding it to the route stack. TreeRouteStack Laminas\\Router\\Http\\TreeRouteStack provides the ability to register trees of routes, and uses a B-tree algorithm to match routes. As such, you register a single route with many children. A TreeRouteStack will consist of the following configuration: A base \"route\", which describes the base match needed, the root of the tree. An optional route_plugins , which is a configured Laminas\\Router\\RoutePluginManager that can lazy-load routes. The option may_terminate , which hints to the router that no other segments will follow it. An optional child_routes array, which contains additional routes that stem from the base \"route\" (i.e., build from it). Each child route can itself be a TreeRouteStack if desired; in fact, the Part route works exactly this way. When a route matches against a TreeRouteStack , the matched parameters from each segment of the tree will be returned. A TreeRouteStack can be your sole route for your application, or describe particular path segments of the application. An example of a TreeRouteStack is provided in the documentation of the Part route. HTTP Route Types laminas-mvc ships with the following HTTP route types. Laminas\\Router\\Http\\Hostname The Hostname route attempts to match the hostname registered in the request against specific criteria. Typically, this will be in one of the following forms: subdomain.domain.tld :subdomain.domain.tld In the above, the second route would return a \"subdomain\" key as part of the route match. For any given hostname segment, you may also provide a constraint. As an example, if the \"subdomain\" segment needed to match only if it started with \"fw\" and contained exactly 2 digits following, the following route would be needed: $route = Hostname::factory([ 'route' => ':subdomain.domain.tld', 'constraints' => [ 'subdomain' => 'fw\\d{2}', ], ]); In the above example, only a \"subdomain\" key will be returned in the RouteMatch . If you wanted to also provide other information based on matching, or a default value to return for the subdomain, you need to also provide defaults. $route = Hostname::factory([ 'route' => ':subdomain.domain.tld', 'constraints' => [ 'subdomain' => 'fw\\d{2}', ], 'defaults' => [ 'type' => 'json', ], ]); When matched, the above will return two keys in the RouteMatch , \"subdomain\" and \"type\". Laminas\\Router\\Http\\Literal The Literal route is for doing exact matching of the URI path. Configuration therefore is solely the path you want to match, and the \"defaults\", or parameters you want returned on a match. $route = Literal::factory([ 'route' => '/foo', 'defaults' => [ 'controller' => 'Application\\Controller\\IndexController', 'action' => 'foo', ], ]); The above route would match a path \"/foo\", and return the key \"action\" in the RouteMatch , with the value \"foo\". Laminas\\Router\\Http\\Method The Method route is used to match the HTTP method or 'verb' specified in the request (See RFC 2616 Sec. 5.1.1). It can optionally be configured to match against multiple methods by providing a comma-separated list of method tokens. $route = Method::factory([ 'verb' => 'post,put', 'defaults' => [ 'controller' => 'Application\\Controller\\IndexController', 'action' => 'form-submit', ], ]); The above route would match an http \"POST\" or \"PUT\" request and return a RouteMatch object containing a key \"action\" with a value of \"form-submit\". Laminas\\Router\\Http\\Part A Part route allows crafting a tree of possible routes based on segments of the URI path. It actually extends the TreeRouteStack . Part routes are difficult to describe, so we'll simply provide a sample one here. $route = Part::factory([ 'route' => [ 'type' => 'literal', 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => 'Application\\Controller\\IndexController', 'action' => 'index', ], ], ], 'route_plugins' => $routePlugins, 'may_terminate' => true, 'child_routes' => [ 'blog' => [ 'type' => 'literal', 'options' => [ 'route' => '/blog', 'defaults' => [ 'controller' => 'Application\\Controller\\BlogController', 'action' => 'index', ], ], 'may_terminate' => true, 'child_routes' => [ 'rss' => [ 'type' => 'literal', 'options' => [ 'route' => '/rss', 'defaults' => [ 'action' => 'rss', ] ], 'may_terminate' => true, 'child_routes' => [ 'subrss' => [ 'type' => 'literal', 'options' => [ 'route' => '/sub', 'defaults' => [ 'action' => 'subrss', ], ], ], ], ], ], ], 'forum' => [ 'type' => 'literal', 'options' => [ 'route' => 'forum', 'defaults' => [ 'controller' => 'Application\\Controller\\ForumController', 'action' => 'index', ], ], ], ], ]); The above would match the following: / would load the \"Index\" controller, \"index\" action. /blog would load the \"Blog\" controller, \"index\" action. /blog/rss would load the \"Blog\" controller, \"rss\" action. /blog/rss/sub would load the \"Blog\" controller, \"subrss\" action. /forum would load the \"Forum\" controller, \"index\" action. You may use any route type as a child route of a Part route. Part routes are an implementation detail Part routes are not meant to be used directly. When you add definitions for child_routes to any route type, that route will become a Part route. As already said, describing Part routes with words is difficult, so hopefully the additional examples at the end will provide further insight. Route plugins In the above example, the $routePlugins is an instance of Laminas\\Router\\RoutePluginManager , containing essentially the following configuration: $$$$FENCED_CODE_BLOCK_5e20ec72450183.80424440 When using Laminas\\Router\\Http\\TreeRouteStack , the RoutePluginManager is set up by default, and the developer does not need to worry about autoloading of standard HTTP routes. Laminas\\Router\\Http\\Regex A Regex route utilizes a regular expression to match against the URI path. Any valid regular expression is allowed; our recommendation is to use named captures for any values you want to return in the RouteMatch . Since regular expression routes are often complex, you must specify a \"spec\" or specification to use when assembling URLs from regex routes. The spec is simply a string; replacements are identified using %keyname% within the string, with the keys coming from either the captured values or named parameters passed to the assemble() method. Just like other routes, the Regex route can accept \"defaults\", parameters to include in the RouteMatch when successfully matched. $route = Regex::factory([ 'regex' => '/blog/(?<id>[a-zA-Z0-9_-]+)(\\.(?<format>(json|html|xml|rss)))?', 'defaults' => [ 'controller' => 'Application\\Controller\\BlogController', 'action' => 'view', 'format' => 'html', ], 'spec' => '/blog/%id%.%format%', ]); The above would match /blog/001-some-blog_slug-here.html , and return four items in the RouteMatch , an \"id\", the \"controller\", the \"action\", and the \"format\". When assembling a URL from this route, the \"id\" and \"format\" values would be used to fill the specification. Laminas\\Router\\Http\\Scheme The Scheme route matches the URI scheme only, and must be an exact match. As such, this route, like the Literal route, simply takes what you want to match and the \"defaults\", parameters to return on a match. $route = Scheme::factory([ 'scheme' => 'https', 'defaults' => [ 'https' => true, ], ]); The above route would match the \"https\" scheme, and return the key \"https\" in the RouteMatch with a boolean true value. Laminas\\Router\\Http\\Segment A Segment route allows matching any segment of a URI path. Segments are denoted using a colon, followed by alphanumeric characters; if a segment is optional, it should be surrounded by brackets. As an example, /:foo[/:bar] would match a / followed by text and assign it to the key \"foo\"; if any additional / characters are found, any text following the last one will be assigned to the key \"bar\". The separation between literal and named segments can be anything. For example, the above could be done as /:foo{-}[-:bar] as well. The {-} after the :foo parameter indicates a set of one or more delimiters, after which matching of the parameter itself ends. Each segment may have constraints associated with it. Each constraint should simply be a regular expression expressing the conditions under which that segment should match. Also, as you can in other routes, you may provide defaults to use; these are particularly useful when using optional segments. As a complex example: $route = Segment::factory([ 'route' => '/:controller[/:action]', 'constraints' => [ 'controller' => '[a-zA-Z][a-zA-Z0-9_-]+', 'action' => '[a-zA-Z][a-zA-Z0-9_-]+', ], 'defaults' => [ 'controller' => 'Application\\Controller\\IndexController', 'action' => 'index', ], ]); Laminas\\Router\\Http\\Query (Deprecated) Potential security issue Misuse of this route can lead to potential security issues. Deprecated This route part is deprecated since you can now add query parameters without a query route. It was removed in version 3 of the router. The Query route part allows you to specify and capture query string parameters for a given route. The intention of the Query part is that you do not instantiate it in its own right, but use it as a child of another route part. An example of its usage would be: $route = Part::factory([ 'route' => [ 'type' => 'literal', 'options' => [ 'route' => 'page', 'defaults' => [], ], ], 'may_terminate' => true, 'route_plugins' => $routePlugins, 'child_routes' => [ 'query' => [ 'type' => 'Query', 'options' => [ 'defaults' => [ 'foo' => 'bar', ], ], ], ], ]); This then allows you to create query strings using the url view helper. $this->url( 'page/query', [ 'name' => 'my-test-page', 'format' => 'rss', 'limit' => 10, ] ); Per the above example, you must add /query (the name we gave to our query route segment) to your route name in order to append a query string. If you do not specify /query in the route name, then no query string will be appended. Our example \"page\" route has only one defined parameter of \"name\" ( /page[/:name] ), meaning that the remaining parameters of \"format\" and \"limit\" will then be appended as a query string. The output from our example should then be /page/my-test-page?format=rss&limit=10 Laminas\\Router\\Http\\Wildcard (Deprecated) Potential security issue Misuse of this route type can lead to potential security issues. Deprecated This route type is deprecated. Use the Segment route type. The Wildcard route type matches all remaining segments of a URI path. HTTP Routing Examples Most of the routing definitions will be done in module configuration files, so the following examples will show how to set up routes in config files. Simple example with two literal routes return [ 'router' => [ 'routes' => [ // Literal route named \"home\" 'home' => [ 'type' => 'literal', 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => 'Application\\Controller\\IndexController', 'action' => 'index', ], ], ], // Literal route named \"contact\" 'contact' => [ 'type' => 'literal', 'options' => [ 'route' => 'contact', 'defaults' => [ 'controller' => 'Application\\Controller\\ContactController', 'action' => 'form', ], ], ], ], ], ]; A complex example with child routes return [ 'router' => [ 'routes' => [ // Literal route named \"home\" 'home' => [ 'type' => 'literal', 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => 'Application\\Controller\\IndexController', 'action' => 'index', ], ], ], // Literal route named \"blog\", with child routes 'blog' => [ 'type' => 'literal', 'options' => [ 'route' => '/blog', 'defaults' => [ 'controller' => 'Application\\Controller\\BlogController', 'action' => 'index', ], ], 'may_terminate' => true, 'child_routes' => [ // Segment route for viewing one blog post 'post' => [ 'type' => 'segment', 'options' => [ 'route' => '/[:slug]', 'constraints' => [ 'slug' => '[a-zA-Z0-9_-]+', ], 'defaults' => [ 'action' => 'view', ], ], ], // Literal route for viewing blog RSS feed 'rss' => [ 'type' => 'literal', 'options' => [ 'route' => '/rss', 'defaults' => [ 'action' => 'rss', ], ], ], ], ], ], ], ]; When using child routes, naming of the routes follows the parent/child pattern, so to use the child routes from the above example: echo $this->url('blog'); // gives \"/blog\" echo $this->url('blog/post', ['slug' => 'my-post']); // gives \"/blog/my-post\" echo $this->url('blog/rss'); // gives \"/blog/rss\" An example with multiple Hostnames and subdomains within a single application return [ 'router' => [ 'routes' => [ 'modules.laminas.dev' => [ 'type' => 'Laminas\\Router\\Http\\Hostname', 'options' => [ 'route' => ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left 'constraints' => [ '4th' => 'modules', '3rd' => '.*?', // optional 3rd level domain such as .ci, .dev or .test '2nd' => 'laminas', '1st' => 'com', ], // Purposely omit default controller and action // to let the child routes control the route match ], // child route controllers may span multiple modules as desired 'child_routes' => [ 'index' => [ 'type' => 'Laminas\\Router\\Http\\Literal', 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => 'Module\\Controller\\Index', 'action' = > 'index', ], ], 'may_terminate' => true, ], ], ], 'packages.laminas.dev' => [ 'type' => 'Laminas\\Router\\Http\\Hostname', 'options' => [ 'route' => ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left 'constraints' => [ '4th' => 'packages', '3rd' => '.*?', // optional 3rd level domain such as .ci, .dev or .test '2nd' => 'laminas', '1st' => 'com', ], // Purposely omit default controller and action // to let the child routes control the route match ], // child route controllers may span multiple modules as desired 'child_routes' => [ 'index' => [ 'type' => 'Laminas\\Router\\Http\\Literal', 'options' => [ 'route' => '/', 'defaults' => [ 'controller' => 'Package\\Controller\\Index', 'action' = > 'index', ], ], 'may_terminate' => true, ], ], ], ], ], ]; The above would match the following: modules.laminas.dev would dispatch the Index controller's index action of the Module module. modules.ci.laminas.dev would dispatch the Index controller's index action of the Module module. packages.laminas.dev would dispatch the Index controller's index action of the Package module. packages.dev.laminas.dev would dispatch the Index controller's index action of the Package module. The Url controller plugin or view helper may be used to generate URLs following the above example: // reuse the route matched parameters to generate URLs echo $this->url('modules.laminas.dev/index', [], [], true); echo $this->url('packages.laminas.dev/index', [], [], true); may_terminate and child_routes placement When defining child routes pay attention that the may_terminate and child_routes definitions are in same level as the options and type definitions. A common pitfall is to have those two definitions nested in options , which will not result in the desired routes. Console Route Types laminas-mvc also allows routing Console based applications; console routes are explained in the laminas-console routing documentation .","title":"Routing"},{"location":"routing/#routing","text":"Routing is the act of matching a request to a given controller. Typically, routing will examine the request URI, and attempt to match the URI path segment against provided constraints. If the constraints match, a set of \"matches\" are returned, one of which should be the controller name to execute. Routing can utilize other portions of the request URI or environment as well. For example, the host or scheme, query parameters, headers, request method, and more. The base unit of routing is a Route : namespace Laminas\\Router; use Laminas\\Stdlib\\RequestInterface as Request; interface RouteInterface { public static function factory(array $options = []); public function match(Request $request); public function assemble(array $params = [], array $options = []); } A Route accepts a Request , and determines if it matches. If so, it returns a RouteMatch object: namespace Laminas\\Router; class RouteMatch { public function __construct(array $params); public function setMatchedRouteName($name); public function getMatchedRouteName(); public function setParam($name, $value); public function getParams(); public function getParam($name, $default = null); } Typically, when a Route matches, it will define one or more parameters. These are passed into the RouteMatch , and objects may query the RouteMatch for their values. $id = $routeMatch->getParam('id', false); if (! $id) { throw new Exception('Required identifier is missing!'); } $entity = $resource->get($id); Usually you will have multiple routes you wish to test against. In order to facilitate this, you will use a route aggregate, usually implementing RouteStack : namespace Laminas\\Router; interface RouteStackInterface extends RouteInterface { public function addRoute($name, $route, $priority = null); public function addRoutes(array $routes); public function removeRoute($name); public function setRoutes(array $routes); } Routes will be queried in a LIFO order, and hence the reason behind the name RouteStack . laminas-mvc provides two implementations of this interface, SimpleRouteStack and TreeRouteStack . In each, you register routes either one at a time using addRoute() , or in bulk using addRoutes() . // One at a time: $route = Literal::factory([ 'route' => '/foo', 'defaults' => [ 'controller' => 'foo-index', 'action' => 'index', ], ]); $router->addRoute('foo', $route); // In bulk: $router->addRoutes([ // using already instantiated routes: 'foo' => $route, // providing configuration to allow lazy-loading routes: 'bar' => [ 'type' => 'literal', 'options' => [ 'route' => '/bar', 'defaults' => [ 'controller' => 'bar-index', 'action' => 'index', ], ], ], ]);","title":"Routing"},{"location":"routing/#router-types","text":"Two routers are provided, the SimpleRouteStack and TreeRouteStack . Each works with the above interface, but utilize slightly different options and execution paths. By default, the laminas-mvc uses the TreeRouteStack as the router.","title":"Router Types"},{"location":"routing/#http-route-types","text":"laminas-mvc ships with the following HTTP route types.","title":"HTTP Route Types"},{"location":"routing/#http-routing-examples","text":"Most of the routing definitions will be done in module configuration files, so the following examples will show how to set up routes in config files.","title":"HTTP Routing Examples"},{"location":"routing/#console-route-types","text":"laminas-mvc also allows routing Console based applications; console routes are explained in the laminas-console routing documentation .","title":"Console Route Types"},{"location":"send-response-event/","text":"The SendResponse Event laminas-mvc defines and utilizes a custom Laminas\\EventManager\\Event for updating the response object prior to emitting it, Laminas\\Mvc\\ResponseSender\\SendResponseEvent . The event allows listeners to set response headers and content. The methods it defines are: setResponse($response) getResponse() setContentSent() contentSent() setHeadersSent() headersSent() Listeners Currently, three listeners are listening to this event at different priorities based on which listener is used most. Class Priority Method Called Description Laminas\\Mvc\\SendResponseListener\\PhpEnvironmentResponseSender -1000 __invoke This is used in HTTP contexts (this is the most often used). Laminas\\Mvc\\SendResponseListener\\ConsoleResponseSender -2000 __invoke This is used in console contexts. Laminas\\Mvc\\SendResponseListener\\SimpleStreamResponseSender -3000 __invoke Because each listener has negative priority, adding your own logic to modify the Response involves adding a new listener without priority (as priority defaults to 1); thus, your own listener will execute before any of the defaults. Triggered By This event is executed when the MvcEvent::FINISH event is triggered, with a priority of -10000.","title":"The SendResponse Event"},{"location":"send-response-event/#the-sendresponse-event","text":"laminas-mvc defines and utilizes a custom Laminas\\EventManager\\Event for updating the response object prior to emitting it, Laminas\\Mvc\\ResponseSender\\SendResponseEvent . The event allows listeners to set response headers and content. The methods it defines are: setResponse($response) getResponse() setContentSent() contentSent() setHeadersSent() headersSent()","title":"The SendResponse Event"},{"location":"send-response-event/#listeners","text":"Currently, three listeners are listening to this event at different priorities based on which listener is used most. Class Priority Method Called Description Laminas\\Mvc\\SendResponseListener\\PhpEnvironmentResponseSender -1000 __invoke This is used in HTTP contexts (this is the most often used). Laminas\\Mvc\\SendResponseListener\\ConsoleResponseSender -2000 __invoke This is used in console contexts. Laminas\\Mvc\\SendResponseListener\\SimpleStreamResponseSender -3000 __invoke Because each listener has negative priority, adding your own logic to modify the Response involves adding a new listener without priority (as priority defaults to 1); thus, your own listener will execute before any of the defaults.","title":"Listeners"},{"location":"send-response-event/#triggered-by","text":"This event is executed when the MvcEvent::FINISH event is triggered, with a priority of -10000.","title":"Triggered By"},{"location":"services/","text":"Default Services The default and recommended way to write laminas-mvc applications uses a set of services defined in the Laminas\\Mvc\\Service namespace. This chapter details what each of those services are, the classes they represent, and the configuration options available. Many of the services are provided by other components, and the factories and abstract factories themselves are defined in the individual components. We will cover those factories in this chapter, however, as usage is generally the same between each. Theory of Operation To allow easy configuration of all the different parts of the MVC system, a somewhat complex set of services and their factories has been created. We'll try to give a simplified explanation of the process. When a Laminas\\Mvc\\Application is created, a Laminas\\ServiceManager\\ServiceManager object is created and configured via Laminas\\Mvc\\Service\\ServiceManagerConfig . The ServiceManagerConfig gets the configuration from config/application.config.php (or some other application configuration you passed to the Application when creating it). From all the service and factories provided in the Laminas\\Mvc\\Service namespace, ServiceManagerConfig is responsible of configuring only three: SharedEventManager , EventManager , and ModuleManager . After this, the Application fetches the ModuleManager . At this point, the ModuleManager further configures the ServiceManager with services and factories provided in Laminas\\Mvc\\Service\\ServiceListenerFactory . This approach allows us to keep the main application configuration concise, and to give the developer the power to configure different parts of the MVC system from within the modules, overriding any default configuration in these MVC services. ServiceManager As a quick review, the following service types may be configured: Invokable services , which map a service name to a class that has no constructor or a constructor that accepts no arguments. Factories , which map a service name to a factory which will create and return an object. A factory receives the service manager as an argument, and may be any PHP callable, or a class or object that implements Laminas\\ServiceManager\\FactoryInterface . Abstract factories , which are factories that can create any number of named services that share the same instantiation pattern; examples include database adapters, cache adapters, loggers, etc. The factory receives the service manager as an argument, the resolved service name, and the requested service name; it must be a class or object implementing Laminas\\ServiceManager\\AbstractFactoryInterface . See the section on abstract factories for configuration information. Aliases , which alias one service name to another. Aliases can also reference other aliases. Initializers , which receive the newly created instance and the service manager, and which can be used to perform additional initialization tasks. The most common use case is to test the instance against specific \"Aware\" interfaces, and, if matching, inject them with the appropriate service. Delegators , which typically decorate retrieval of a service to either substitute an alternate service, decorate the created service, or perform pre/post initialization tasks when creating a service. Lazy services , which are decorators for services with expensive initialization; the service manager essentially returns a proxy service that defers initialization until the first call is made to the service. Plugin managers , which are specialized service managers used to manage objects that are of a related type, such as view helpers, controller plugins, controllers, etc. Plugin managers accept configuration just like service managers, and as such can compose each of the service types listed above. They are also ServiceLocatorAware , and will be injected with the application service manager instance, giving factories and abstract factories access to application-level services when needed. See the heading Plugin managers for a list of available plugin managers. The application service manager is referenced directly during bootstrapping, and has the following services configured out of the box. Invokable services DispatchListener , mapping to Laminas\\Mvc\\DispatchListener . Laminas\\Mvc\\MiddlewareListener . RouteListener , mapping to Laminas\\Mvc\\RouteListener . SendResponseListener , mapping to Laminas\\Mvc\\SendResponseListener . SharedEventManager , mapping to Laminas\\EventManager\\SharedEventManager . Factories Application , mapping to Laminas\\Mvc\\Service\\ApplicationFactory . Config , mapping to Laminas\\Mvc\\Service\\ConfigFactory . Internally, this pulls the ModuleManager service, calls its loadModules() method, and retrieves the merged configuration from the module event. As such, this service contains the entire, merged application configuration. ControllerManager , mapping to Laminas\\Mvc\\Service\\ControllerLoaderFactory . This creates an instance of Laminas\\Mvc\\Controller\\ControllerManager , passing the service manager instance. Additionally, it uses the DiStrictAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve your controllers. If you want to use Laminas\\Di to retrieve your controllers, you must white-list them in your DI configuration under the allowed_controllers key (otherwise, they will just be ignored). The ControllerManager provides initializers for the following: If the controller implements Laminas\\ServiceManager\\ServiceLocatorAwareInterface (or the methods it defines), an instance of the ServiceManager will be injected into it. If the controller implements Laminas\\EventManager\\EventManagerAwareInterface , an instance of the EventManager will be injected into it. Finally, an initializer will inject it with the ControllerPluginManager service, as long as the setPluginManager method is implemented. ControllerPluginManager , mapping to Laminas\\Mvc\\Service\\ControllerPluginManagerFactory . This instantiates the Laminas\\Mvc\\Controller\\PluginManager instance, passing it the service manager instance. It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve your controller plugins . It registers a set of default controller plugins, and contains an initializer for injecting plugins with the current controller. ConsoleAdapter , mapping to Laminas\\Mvc\\Service\\ConsoleAdapterFactory . This grabs the Config service, pulls from the console key, and do the following: If the adapter subkey is present, it is used to get the adapter instance, otherwise, Laminas\\Console\\Console::detectBestAdapter() will be called to configure an adapter instance. If the charset subkey is present, the value is used to set the adapter charset. ConsoleRouter , mapping to Laminas\\Mvc\\Console\\Router\\ConsoleRouterFactory . This grabs the Config service, and pulls from the console key and router subkey, configuring a Laminas\\Mvc\\Console\\Router\\SimpleRouteStack instance. ConsoleViewManager , mapping to Laminas\\Mvc\\Service\\ConsoleViewManagerFactory . This creates and returns an instance of Laminas\\Mvc\\View\\Console\\ViewManager , which in turn registers and initializes a number of console-specific view services. DependencyInjector , mapping to Laminas\\Mvc\\Service\\DiFactory . This pulls the Config service, and looks for a \"di\" key; if found, that value is used to configure a new Laminas\\Di\\Di instance. DiAbstractServiceFactory , mapping to Laminas\\Mvc\\Service\\DiAbstractServiceFactoryFactory . This creates an instance of Laminas\\ServiceManager\\Di\\DiAbstractServiceFactory injecting the Di service instance. That instance is attached to the service manager as an abstract factory, effectively enabling DI as a fallback for providing services. DiServiceInitializer , mapping to Laminas\\Mvc\\Service\\DiServiceInitializerFactory . This creates an instance of Laminas\\ServiceManager\\Di\\DiServiceInitializer injecting the Di service and the service manager itself. DiStrictAbstractServiceFactory , mapping to Laminas\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory . This creates an instance of Laminas\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory , injecting the Di service instance. EventManager , mapping to Laminas\\Mvc\\Service\\EventManagerFactory . This factory returns a discrete instance of Laminas\\EventManager\\EventManager on each request. This service is not shared by default, allowing the ability to have an EventManager per service, with a shared SharedEventManager injected in each. FilterManager , mapping to Laminas\\Mvc\\Service\\FilterManagerFactory . This instantiates the Laminas\\Filter\\FilterPluginManager instance, passing it the service manager instance; this is used to manage filters for filter chains . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve filters. FormElementManager , mapping to Laminas\\Mvc\\Service\\FormElementManagerFactory . This instantiates the Laminas\\Form\\FormElementManager instance, passing it the service manager instance; this is used to manage form elements . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve form elements. HttpRouter , mapping to Laminas\\Router\\Http\\HttpRouterFactory . This grabs the Config service, and pulls from the router key, configuring a Laminas\\Router\\Http\\TreeRouteStack instance. HttpViewManager , mapping to Laminas\\Mvc\\Service\\HttpViewManagerFactory . This creates and returns an instance of Laminas\\Mvc\\View\\Http\\ViewManager , which in turn registers and initializes a number of HTTP-specific view services. HydratorManager , mapping to Laminas\\Mvc\\Service\\HydratorManagerFactory . This creates and returns an instance of Laminas\\Stdlib\\Hydrator\\HydratorPluginManager , which can be used to manage and persist hydrator instances. InputFilterManager , mapping to Laminas\\Mvc\\Service\\InputFilterManagerFactory . This creates and returns an instance of Laminas\\InputFilter\\InputFilterPluginManager , which can be used to manage and persist input filter instances. ModuleManager , mapping to Laminas\\Mvc\\Service\\ModuleManagerFactory . This is perhaps the most complex factory in the MVC stack. It expects that an ApplicationConfig service has been injected, with keys for module_listener_options and modules ; see the quick start for samples. It creates an instance of Laminas\\ModuleManager\\Listener\\DefaultListenerAggregate , using the module_listener_options retrieved. It then checks if a service with the name ServiceListener exists; if not, it sets a factory with that name mapping to Laminas\\Mvc\\Service\\ServiceListenerFactory . A bunch of service listeners will be added to the ServiceListener , like listeners for the getServiceConfig , getControllerConfig , getControllerPluginConfig , and getViewHelperConfig module methods. Next, it retrieves the EventManager service, and attaches the above listeners. It instantiates a Laminas\\ModuleManager\\ModuleEvent instance, setting the \"ServiceManager\" parameter to the service manager object. Finally, it instantiates a Laminas\\ModuleManager\\ModuleManager instance, and injects the EventManager and ModuleEvent . MvcTranslator , mapping to Laminas\\Mvc\\Service\\TranslatorServiceFactory , and returning an instance of Laminas\\Mvc\\I18n\\Translator , which extends Laminas\\I18n\\Translator\\Translator and implements Laminas\\Validator\\Translator\\TranslatorInterface , allowing the instance to be used anywhere a translator may be required in the framework. PaginatorPluginManager , mapping to Laminas\\Mvc\\Service\\PaginatorPluginManagerFactory . This instantiates the Laminas\\Paginator\\AdapterPluginManager instance, passing it the service manager instance. This is used to manage paginator adapters . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve paginator adapters. Request , mapping to Laminas\\Mvc\\Service\\RequestFactory . The factory is used to create and return a request instance, according to the current environment. If the current environment is a console environment, it will create a Laminas\\Console\\Request ; otherwise, for HTTP environments, it creates a Laminas\\Http\\PhpEnvironment\\Request . Response , mapping to Laminas\\Mvc\\Service\\ResponseFactory . The factory is used to create and return a response instance, according to the current environment. If the current environment is a console environment, it will create a Laminas\\Console\\Response ; otherwise, for HTTP environments, it creates a Laminas\\Http\\PhpEnvironment\\Response . Router , mapping to Laminas\\Router\\RouterFactory . If in a console environment, it proxies to the ConsoleRouter service; otherwise, it proxies to the HttpRouter service. RoutePluginManager , mapping to Laminas\\Mvc\\Service\\RoutePluginManagerFactory . This instantiates the Laminas\\Router\\RoutePluginManager instance, passing it the service manager instance; this is used to manage route types . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve route types. SerializerAdapterManager , mapping to Laminas\\Mvc\\Service\\SerializerAdapterPluginManagerFactory , which returns an instance of Laminas\\Serializer\\AdapterPluginManager . This is a plugin manager for managing serializer adapter instances. ServiceListener , mapping to Laminas\\Mvc\\Service\\ServiceListenerFactory . The factory is used to instantiate the ServiceListener , while allowing easy extending. It checks if a service with the name ServiceListenerInterface exists, which must implement Laminas\\ModuleManager\\Listener\\ServiceListenerInterface , before instantiating the default ServiceListener . In addition to this, it retrieves the ApplicationConfig and looks for the service_listener_options key. This allows you to register own listeners for module methods and configuration keys to create an own service manager; see the application configuration options for samples. ValidatorManager , mapping to Laminas\\Mvc\\Service\\ValidatorManagerFactory . This instantiates the Laminas\\Validator\\ValidatorPluginManager instance, passing it the service manager instance. This is used to manage validators . It also uses the DiAbstractServiceFactory service, effectively allowing you to fall back to DI in order to retrieve validators. ViewFeedRenderer , mapping to Laminas\\Mvc\\Service\\ViewFeedRendererFactory , which returns an instance of Laminas\\View\\Renderer\\FeedRenderer , used to render feeds. ViewFeedStrategy , mapping to Laminas\\Mvc\\Service\\ViewFeedStrategyFactory , which returns an instance of Laminas\\View\\Strategy\\FeedStrategy , used to select the ViewFeedRenderer given the appropriate criteria. ViewHelperManager , mapping to Laminas\\Mvc\\Service\\ViewHelperManagerFactory , which returns an instance of Laminas\\View\\HelperManager . This is a plugin manager for managing view helper instances. ViewJsonRenderer , mapping to Laminas\\Mvc\\Service\\ViewJsonRendererFactory , which returns an instance of Laminas\\View\\Renderer\\JsonRenderer , used to render JSON structures. ViewJsonStrategy , mapping to Laminas\\Mvc\\Service\\ViewJsonStrategyFactory , which returns an instance of Laminas\\View\\Strategy\\JsonStrategy , used to select the ViewJsonRenderer given the appropriate criteria. ViewManager , mapping to Laminas\\Mvc\\Service\\ViewManagerFactory . The factory is used to create and return a view manager, according to the current environment. If the current environment is a console environment, it will create a Laminas\\Mvc\\View\\Console\\ViewManager ; otherwise, for HTTP environments, it returns a Laminas\\Mvc\\View\\Http\\ViewManager . ViewResolver , mapping to Laminas\\Mvc\\Service\\ViewResolverFactory , which creates and returns the aggregate view resolver. It also attaches the ViewTemplateMapResolver and ViewTemplatePathStack services to it. ViewTemplateMapResolver , mapping to Laminas\\Mvc\\Service\\ViewTemplateMapResolverFactory , which creates, configures and returns the Laminas\\View\\Resolver\\TemplateMapResolver . ViewTemplatePathStack , mapping to Laminas\\Mvc\\Service\\ViewTemplatePathStackFactory , which creates, configures and returns the Laminas\\View\\Resolver\\TemplatePathStack . Abstract factories Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory (opt-in; registered by default in the skeleton application). Laminas\\Db\\Adapter\\AdapterAbstractServiceFactory (opt-in). Laminas\\Form\\FormAbstractServiceFactory is registered by default. Laminas\\Log\\LoggerAbstractServiceFactory (opt-in; registered by default in the skeleton application). Aliases Configuration , mapping to the Config service. Console , mapping to the ConsoleAdapter service. Di , mapping to the DependencyInjector service. MiddlewareListener , mapping to the Laminas\\Mvc\\MiddlewareListener service. Laminas\\Di\\LocatorInterface , mapping to the DependencyInjector service. Laminas\\EventManager\\EventManagerInterface , mapping to the EventManager service. This is mainly to ensure that when falling through to DI, classes are still injected via the ServiceManager . Laminas\\Mvc\\Controller\\PluginManager , mapping to the ControllerPluginManager service. This is mainly to ensure that when falling through to DI, classes are still injected via the ServiceManager . Laminas\\View\\Resolver\\TemplateMapResolver , mapping to the ViewTemplateMapResolver service. Laminas\\View\\Resolver\\TemplatePathStack , mapping to the ViewTemplatePathStack service. Laminas\\View\\Resolver\\AggregateResolver , mapping to the ViewResolver service. Laminas\\View\\Resolver\\ResolverInterface , mapping to the ViewResolver service. Initializers For objects that implement Laminas\\EventManager\\EventManagerAwareInterface , the EventManager service will be retrieved and injected. This service is not shared, though each instance it creates is injected with a shared instance of SharedEventManager . For objects that implement Laminas\\ServiceManager\\ServiceLocatorAwareInterface (or the methods it defines), the ServiceManager will inject itself into the object. The ServiceManager registers itself as the ServiceManager service, and aliases itself to the class names Laminas\\ServiceManager\\ServiceLocatorInterface and Laminas\\ServiceManager\\ServiceManager . Abstract Factories As noted in the previous section, Laminas provides a number of abstract service factories by default. Each is noted below, along with sample configuration. In each instance, the abstract factory looks for a top-level configuration key, consisting of key/value pairs where the key is the service name, and the value is the configuration to use to create the given service. Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory This abstract factory is opt-in, but registered by default in the skeleton application. It uses the top-level configuration key \"caches\". return [ 'caches' => [ 'Cache\\Transient' => [ 'adapter' => 'redis', 'ttl' => 60, 'plugins' => [ 'exception_handler' => [ 'throw_exceptions' => false, ], ], ], 'Cache\\Persistence' => [ 'adapter' => 'filesystem', 'ttl' => 86400, ], ], ]; See the cache documentation for more configuration options. Laminas\\Db\\Adapter\\AdapterAbstractServiceFactory This abstract factory is opt-in. It uses the top-level configuration key \"db\", with a subkey \"adapters\". return [ 'db' => ['adapters' => [ 'Db\\ReadOnly' => [ 'driver' => 'Pdo_Sqlite', 'database' => 'data/db/users.db', ], 'Db\\Writeable' => [ 'driver' => 'Mysqli', 'database' => 'users', 'username' => 'developer', 'password' => 'developer_password', ], ]], ]; See the DB adapter documentation for more configuration options. Laminas\\Form\\FormAbstractServiceFactory This abstract factory is registered by default. It uses the top-level configuration key \"forms\". It makes use of the FilterManager , FormElementManager , HydratorManager , InputFilterManager , and ValidatorManager plugin managers in order to allow instantiation and creation of form objects and all related objects in the form hierarchy. return [ 'forms' => [ 'Form\\Foo' => [ 'hydrator' => 'ObjectProperty', 'type' => 'Laminas\\Form\\Form', 'elements' => [ [ 'spec' => [ 'type' => 'Laminas\\Form\\Element\\Email', 'name' => 'email', 'options' => [ 'label' => 'Your email address', ], ], ], ], ], ], ]; Form configuration follows the same configuration you would use with a form factory; the primary difference is that all plugin managers have already been injected for you, allowing you the possibility of custom objects or substitutions. See the form factory documentation for more configuration options. Laminas\\Log\\LoggerAbstractServiceFactory This abstract factory is opt-in, but registered by default in the skeleton application. It uses the top-level configuration key \"log\". return [ 'log' => [ 'Log\\App' => [ 'writers' => [ [ 'name' => 'stream', 'priority' => 1000, 'options' => [ 'stream' => 'data/logs/app.log', ], ], ], ], ], ]; See the log documentation for more configuration options. Plugin Managers The following plugin managers are configured by default: ControllerManager , corresponding to Laminas\\Mvc\\Controller\\ControllerManager , and used to manage controller instances. ControllerPluginManager , corresponding to Laminas\\Mvc\\Controller\\PluginManager , and used to manage controller plugin instances. FilterManager , corresponding to Laminas\\Filter\\FilterPluginManager , and used to manage filter instances. FormElementManager , corresponding to Laminas\\Form\\FormElementManager , and used to manage instances of form elements and fieldsets. HydratorManager , corresponding to Laminas\\Stdlib\\Hydrator\\HydratorPluginManager , and used to manage hydrator instances. InputFilterManager , corresponding to Laminas\\InputFilter\\InputFilterPluginManager , and used to manage input filter instances. RoutePluginManager , corresponding to Laminas\\Router\\RoutePluginManager , and used to manage route instances. SerializerAdapterManager , corresponding to Laminas\\Serializer\\AdapterPluginManager , and used to manage serializer instances. ValidatorManager , corresponding to Laminas\\Validator\\ValidatorPluginManager , and used to manage validator instances. ViewHelperManager , corresponding to Laminas\\View\\HelperPluginManager , and used to manage view helper instances. As noted in the previous section, all plugin managers share the same configuration and service types as the standard service manager; they are simply scoped, and only allow instances of certain types to be created or registered. Default types available are listed in the documentation for each component. ViewManager The View layer within laminas-mvc consists of a large number of collaborators and event listeners. As such, Laminas\\Mvc\\View\\ViewManager was created to handle creation of the various objects, as well as wiring them together and establishing event listeners. The ViewManager itself is an event listener on the bootstrap event. It retrieves the ServiceManager from the Application object, as well as its composed EventManager . Configuration for all members of the ViewManager fall under the view_manager configuration key, and expect values as noted below. The following services are created and managed by the ViewManager : ViewHelperManager , representing and aliased to Laminas\\View\\HelperPluginManager . It is seeded with the ServiceManager . Created via the Laminas\\Mvc\\Service\\ViewHelperManagerFactory . The Router service is retrieved, and injected into the Url helper. If the base_path key is present, it is used to inject the BasePath view helper; otherwise, the Request service is retrieved, and the value of its getBasePath() method is used. If the base_path_console key is present, it is used to inject the BasePath view helper for console requests; otherwise, the Request service is retrieved, and the value of its getBasePath() method is used. This can be useful for sending urls in emails via a cronjob. If the doctype key is present, it will be used to set the value of the Doctype view helper. ViewTemplateMapResolver , representing and aliased to Laminas\\View\\Resolver\\TemplateMapResolver . If a template_map key is present, it will be used to seed the template map. ViewTemplatePathStack , representing and aliased to Laminas\\View\\Resolver\\TemplatePathStack . If a template_path_stack key is present, it will be used to seed the stack. If a default_template_suffix key is present, it will be used as the default suffix for template scripts resolving. ViewResolver , representing and aliased to Laminas\\View\\Resolver\\AggregateResolver and Laminas\\View\\Resolver\\ResolverInterface . It is seeded with the ViewTemplateMapResolver and ViewTemplatePathStack services as resolvers. ViewRenderer , representing and aliased to Laminas\\View\\Renderer\\PhpRenderer and Laminas\\View\\Renderer\\RendererInterface . It is seeded with the ViewResolver and ViewHelperManager services. Additionally, the ViewModel helper gets seeded with the ViewModel as its root (layout) model. ViewPhpRendererStrategy , representing and aliased to Laminas\\View\\Strategy\\PhpRendererStrategy . It gets seeded with the ViewRenderer service. View , representing and aliased to Laminas\\View\\View . It gets seeded with the EventManager service, and attaches the ViewPhpRendererStrategy as an aggregate listener. DefaultRenderingStrategy , representing and aliased to Laminas\\Mvc\\View\\DefaultRenderingStrategy . If the layout key is present, it is used to seed the strategy's layout template. It is seeded with the View service. ExceptionStrategy , representing and aliased to Laminas\\Mvc\\View\\ExceptionStrategy . If the display_exceptions or exception_template keys are present, they are used to configure the strategy. RouteNotFoundStrategy , representing and aliased to Laminas\\Mvc\\View\\RouteNotFoundStrategy and 404Strategy . If the display_not_found_reason or not_found_template keys are present, they are used to configure the strategy. ViewModel . In this case, no service is registered; the ViewModel is retrieved from the MvcEvent and injected with the layout template name. The ViewManager also creates several other listeners, but does not expose them as services; these include Laminas\\Mvc\\View\\CreateViewModelListener , Laminas\\Mvc\\View\\InjectTemplateListener , and Laminas\\Mvc\\View\\InjectViewModelListener . These, along with RouteNotFoundStrategy , ExceptionStrategy , and DefaultRenderingStrategy are attached as listeners either to the application EventManager instance or the SharedEventManager instance. Finally, if you have a strategies key in your configuration, the ViewManager will loop over these and attach them in order to the View service as listeners, at a priority of 100 (allowing them to execute before the DefaultRenderingStrategy ). Application Configuration Options The following options may be used to provide initial configuration for the ServiceManager , ModuleManager , and Application instances, allowing them to then find and aggregate the configuration used for the Config service, which is intended for configuring all other objects in the system. These configuration directives go to the config/application.config.php file. <?php return [ // This should be an array of module namespaces used in the application. 'modules' => [ ], // These are various options for the listeners attached to the ModuleManager 'module_listener_options' => [ // This should be an array of paths in which modules reside. // If a string key is provided, the listener will consider that a module // namespace, the value of that key the specific path to that module's // Module class. 'module_paths' => [ ], // An array of paths from which to glob configuration files after // modules are loaded. These effectively override configuration // provided by modules themselves. Paths may use GLOB_BRACE notation. 'config_glob_paths' => [ ], // Whether or not to enable a configuration cache. // If enabled, the merged configuration will be cached and used in // subsequent requests. 'config_cache_enabled' => $booleanValue, // The key used to create the configuration cache file name. 'config_cache_key' => $stringKey, // Whether or not to enable a module class map cache. // If enabled, creates a module class map cache which will be used // by in future requests, to reduce the autoloading process. 'module_map_cache_enabled' => $booleanValue, // The key used to create the class map cache file name. 'module_map_cache_key' => $stringKey, // The path in which to cache merged configuration. 'cache_dir' => $stringPath, // Whether or not to enable modules dependency checking. // Enabled by default, prevents usage of modules that depend on other modules // that weren't loaded. 'check_dependencies' => $booleanValue, ], // Used to create an own service manager. May contain one or more child arrays. 'service_listener_options' => [ [ 'service_manager' => $stringServiceManagerName, 'config_key' => $stringConfigKey, 'interface' => $stringOptionalInterface, 'method' => $stringRequiredMethodName, ], ] // Initial configuration with which to seed the ServiceManager. // Should be compatible with Laminas\\ServiceManager\\Config. 'service_manager' => [ ], ]; For an example, see the laminas-mvc-skeleton configuration file . Default Configuration Options The following options are available when using the default services configured by the ServiceManagerConfig and ViewManager . These configuration directives can go to the config/autoload/{{,*.}global,{,*.}local}.php files, or in the module/<module name>/config/module.config.php configuration files. The merging of these configuration files is done by the ModuleManager . It first merges each module's module.config.php file, and then the files in config/autoload (first the *.global.php and then the *.local.php files). The order of the merge is relevant so you can override a module's configuration with your application configuration. If you have both a config/autoload/my.global.config.php and config/autoload/my.local.config.php , the local configuration file overrides the global configuration. Do not commit local configuration Local configuration files are intended to keep sensitive information, such as database credentials, and as such, it is highly recommended to keep these local configuration files out of your VCS. The laminas-mvc-skeleton 's config/autoload/.gitignore file ignores *.local.php files by default. <?php return [ // The following are used to configure controller loader // Should be compatible with Laminas\\ServiceManager\\Config. 'controllers' => [ // Map of controller \"name\" to class // This should be used if you do not need to inject any dependencies // in your controller 'invokables' => [ ], // Map of controller \"name\" to factory for creating controller instance // You may provide either the class name of a factory, or a PHP callback. 'factories' => [ ], ], // The following are used to configure controller plugin loader // Should be compatible with Laminas\\ServiceManager\\Config. 'controller_plugins' => [ ], // The following are used to configure view helper manager // Should be compatible with Laminas\\ServiceManager\\Config. 'view_helpers' => [ ], // The following is used to configure a Laminas\\Di\\Di instance. // The array should be in a format that Laminas\\Di\\Config can understand. 'di' => [ ], // Configuration for the Router service // Can contain any router configuration, but typically will always define // the routes for the application. See the router documentation for details // on route configuration. 'router' => [ 'routes' => [ ], ], // ViewManager configuration 'view_manager' => [ // Base URL path to the application 'base_path' => $stringBasePath, // Doctype with which to seed the Doctype helper 'doctype' => $doctypeHelperConstantString, // e.g. HTML5, XHTML1 // TemplateMapResolver configuration // template/path pairs 'template_map' => [ ], // TemplatePathStack configuration // module/view script path pairs 'template_path_stack' => [ ], // Default suffix to use when resolving template scripts, if none, 'phtml' is used 'default_template_suffix' => $templateSuffix, // e.g. 'php' // Controller namespace to template map 'controller_map' => [ ], // Layout template name 'layout' => $layoutTemplateName, // e.g. 'layout/layout' // ExceptionStrategy configuration 'display_exceptions' => $bool, // display exceptions in template 'exception_template' => $stringTemplateName, // e.g. 'error' // RouteNotFoundStrategy configuration 'display_not_found_reason' => $bool, // display 404 reason in template 'not_found_template' => $stringTemplateName, // e.g. '404' // Additional strategies to attach // These should be class names or service names of View strategy classes // that act as ListenerAggregates. They will be attached at priority 100, // in the order registered. 'strategies' => [ 'ViewJsonStrategy', // register JSON renderer strategy 'ViewFeedStrategy', // register Feed renderer strategy ], ], ]; For an example, see the Application module configuration file in the laminas-mvc-skeleton.","title":"Default Services"},{"location":"services/#default-services","text":"The default and recommended way to write laminas-mvc applications uses a set of services defined in the Laminas\\Mvc\\Service namespace. This chapter details what each of those services are, the classes they represent, and the configuration options available. Many of the services are provided by other components, and the factories and abstract factories themselves are defined in the individual components. We will cover those factories in this chapter, however, as usage is generally the same between each.","title":"Default Services"},{"location":"services/#theory-of-operation","text":"To allow easy configuration of all the different parts of the MVC system, a somewhat complex set of services and their factories has been created. We'll try to give a simplified explanation of the process. When a Laminas\\Mvc\\Application is created, a Laminas\\ServiceManager\\ServiceManager object is created and configured via Laminas\\Mvc\\Service\\ServiceManagerConfig . The ServiceManagerConfig gets the configuration from config/application.config.php (or some other application configuration you passed to the Application when creating it). From all the service and factories provided in the Laminas\\Mvc\\Service namespace, ServiceManagerConfig is responsible of configuring only three: SharedEventManager , EventManager , and ModuleManager . After this, the Application fetches the ModuleManager . At this point, the ModuleManager further configures the ServiceManager with services and factories provided in Laminas\\Mvc\\Service\\ServiceListenerFactory . This approach allows us to keep the main application configuration concise, and to give the developer the power to configure different parts of the MVC system from within the modules, overriding any default configuration in these MVC services.","title":"Theory of Operation"},{"location":"services/#servicemanager","text":"As a quick review, the following service types may be configured: Invokable services , which map a service name to a class that has no constructor or a constructor that accepts no arguments. Factories , which map a service name to a factory which will create and return an object. A factory receives the service manager as an argument, and may be any PHP callable, or a class or object that implements Laminas\\ServiceManager\\FactoryInterface . Abstract factories , which are factories that can create any number of named services that share the same instantiation pattern; examples include database adapters, cache adapters, loggers, etc. The factory receives the service manager as an argument, the resolved service name, and the requested service name; it must be a class or object implementing Laminas\\ServiceManager\\AbstractFactoryInterface . See the section on abstract factories for configuration information. Aliases , which alias one service name to another. Aliases can also reference other aliases. Initializers , which receive the newly created instance and the service manager, and which can be used to perform additional initialization tasks. The most common use case is to test the instance against specific \"Aware\" interfaces, and, if matching, inject them with the appropriate service. Delegators , which typically decorate retrieval of a service to either substitute an alternate service, decorate the created service, or perform pre/post initialization tasks when creating a service. Lazy services , which are decorators for services with expensive initialization; the service manager essentially returns a proxy service that defers initialization until the first call is made to the service. Plugin managers , which are specialized service managers used to manage objects that are of a related type, such as view helpers, controller plugins, controllers, etc. Plugin managers accept configuration just like service managers, and as such can compose each of the service types listed above. They are also ServiceLocatorAware , and will be injected with the application service manager instance, giving factories and abstract factories access to application-level services when needed. See the heading Plugin managers for a list of available plugin managers. The application service manager is referenced directly during bootstrapping, and has the following services configured out of the box.","title":"ServiceManager"},{"location":"services/#abstract-factories","text":"As noted in the previous section, Laminas provides a number of abstract service factories by default. Each is noted below, along with sample configuration. In each instance, the abstract factory looks for a top-level configuration key, consisting of key/value pairs where the key is the service name, and the value is the configuration to use to create the given service.","title":"Abstract Factories"},{"location":"services/#plugin-managers","text":"The following plugin managers are configured by default: ControllerManager , corresponding to Laminas\\Mvc\\Controller\\ControllerManager , and used to manage controller instances. ControllerPluginManager , corresponding to Laminas\\Mvc\\Controller\\PluginManager , and used to manage controller plugin instances. FilterManager , corresponding to Laminas\\Filter\\FilterPluginManager , and used to manage filter instances. FormElementManager , corresponding to Laminas\\Form\\FormElementManager , and used to manage instances of form elements and fieldsets. HydratorManager , corresponding to Laminas\\Stdlib\\Hydrator\\HydratorPluginManager , and used to manage hydrator instances. InputFilterManager , corresponding to Laminas\\InputFilter\\InputFilterPluginManager , and used to manage input filter instances. RoutePluginManager , corresponding to Laminas\\Router\\RoutePluginManager , and used to manage route instances. SerializerAdapterManager , corresponding to Laminas\\Serializer\\AdapterPluginManager , and used to manage serializer instances. ValidatorManager , corresponding to Laminas\\Validator\\ValidatorPluginManager , and used to manage validator instances. ViewHelperManager , corresponding to Laminas\\View\\HelperPluginManager , and used to manage view helper instances. As noted in the previous section, all plugin managers share the same configuration and service types as the standard service manager; they are simply scoped, and only allow instances of certain types to be created or registered. Default types available are listed in the documentation for each component.","title":"Plugin Managers"},{"location":"services/#viewmanager","text":"The View layer within laminas-mvc consists of a large number of collaborators and event listeners. As such, Laminas\\Mvc\\View\\ViewManager was created to handle creation of the various objects, as well as wiring them together and establishing event listeners. The ViewManager itself is an event listener on the bootstrap event. It retrieves the ServiceManager from the Application object, as well as its composed EventManager . Configuration for all members of the ViewManager fall under the view_manager configuration key, and expect values as noted below. The following services are created and managed by the ViewManager : ViewHelperManager , representing and aliased to Laminas\\View\\HelperPluginManager . It is seeded with the ServiceManager . Created via the Laminas\\Mvc\\Service\\ViewHelperManagerFactory . The Router service is retrieved, and injected into the Url helper. If the base_path key is present, it is used to inject the BasePath view helper; otherwise, the Request service is retrieved, and the value of its getBasePath() method is used. If the base_path_console key is present, it is used to inject the BasePath view helper for console requests; otherwise, the Request service is retrieved, and the value of its getBasePath() method is used. This can be useful for sending urls in emails via a cronjob. If the doctype key is present, it will be used to set the value of the Doctype view helper. ViewTemplateMapResolver , representing and aliased to Laminas\\View\\Resolver\\TemplateMapResolver . If a template_map key is present, it will be used to seed the template map. ViewTemplatePathStack , representing and aliased to Laminas\\View\\Resolver\\TemplatePathStack . If a template_path_stack key is present, it will be used to seed the stack. If a default_template_suffix key is present, it will be used as the default suffix for template scripts resolving. ViewResolver , representing and aliased to Laminas\\View\\Resolver\\AggregateResolver and Laminas\\View\\Resolver\\ResolverInterface . It is seeded with the ViewTemplateMapResolver and ViewTemplatePathStack services as resolvers. ViewRenderer , representing and aliased to Laminas\\View\\Renderer\\PhpRenderer and Laminas\\View\\Renderer\\RendererInterface . It is seeded with the ViewResolver and ViewHelperManager services. Additionally, the ViewModel helper gets seeded with the ViewModel as its root (layout) model. ViewPhpRendererStrategy , representing and aliased to Laminas\\View\\Strategy\\PhpRendererStrategy . It gets seeded with the ViewRenderer service. View , representing and aliased to Laminas\\View\\View . It gets seeded with the EventManager service, and attaches the ViewPhpRendererStrategy as an aggregate listener. DefaultRenderingStrategy , representing and aliased to Laminas\\Mvc\\View\\DefaultRenderingStrategy . If the layout key is present, it is used to seed the strategy's layout template. It is seeded with the View service. ExceptionStrategy , representing and aliased to Laminas\\Mvc\\View\\ExceptionStrategy . If the display_exceptions or exception_template keys are present, they are used to configure the strategy. RouteNotFoundStrategy , representing and aliased to Laminas\\Mvc\\View\\RouteNotFoundStrategy and 404Strategy . If the display_not_found_reason or not_found_template keys are present, they are used to configure the strategy. ViewModel . In this case, no service is registered; the ViewModel is retrieved from the MvcEvent and injected with the layout template name. The ViewManager also creates several other listeners, but does not expose them as services; these include Laminas\\Mvc\\View\\CreateViewModelListener , Laminas\\Mvc\\View\\InjectTemplateListener , and Laminas\\Mvc\\View\\InjectViewModelListener . These, along with RouteNotFoundStrategy , ExceptionStrategy , and DefaultRenderingStrategy are attached as listeners either to the application EventManager instance or the SharedEventManager instance. Finally, if you have a strategies key in your configuration, the ViewManager will loop over these and attach them in order to the View service as listeners, at a priority of 100 (allowing them to execute before the DefaultRenderingStrategy ).","title":"ViewManager"},{"location":"services/#application-configuration-options","text":"The following options may be used to provide initial configuration for the ServiceManager , ModuleManager , and Application instances, allowing them to then find and aggregate the configuration used for the Config service, which is intended for configuring all other objects in the system. These configuration directives go to the config/application.config.php file. <?php return [ // This should be an array of module namespaces used in the application. 'modules' => [ ], // These are various options for the listeners attached to the ModuleManager 'module_listener_options' => [ // This should be an array of paths in which modules reside. // If a string key is provided, the listener will consider that a module // namespace, the value of that key the specific path to that module's // Module class. 'module_paths' => [ ], // An array of paths from which to glob configuration files after // modules are loaded. These effectively override configuration // provided by modules themselves. Paths may use GLOB_BRACE notation. 'config_glob_paths' => [ ], // Whether or not to enable a configuration cache. // If enabled, the merged configuration will be cached and used in // subsequent requests. 'config_cache_enabled' => $booleanValue, // The key used to create the configuration cache file name. 'config_cache_key' => $stringKey, // Whether or not to enable a module class map cache. // If enabled, creates a module class map cache which will be used // by in future requests, to reduce the autoloading process. 'module_map_cache_enabled' => $booleanValue, // The key used to create the class map cache file name. 'module_map_cache_key' => $stringKey, // The path in which to cache merged configuration. 'cache_dir' => $stringPath, // Whether or not to enable modules dependency checking. // Enabled by default, prevents usage of modules that depend on other modules // that weren't loaded. 'check_dependencies' => $booleanValue, ], // Used to create an own service manager. May contain one or more child arrays. 'service_listener_options' => [ [ 'service_manager' => $stringServiceManagerName, 'config_key' => $stringConfigKey, 'interface' => $stringOptionalInterface, 'method' => $stringRequiredMethodName, ], ] // Initial configuration with which to seed the ServiceManager. // Should be compatible with Laminas\\ServiceManager\\Config. 'service_manager' => [ ], ]; For an example, see the laminas-mvc-skeleton configuration file .","title":"Application Configuration Options"},{"location":"services/#default-configuration-options","text":"The following options are available when using the default services configured by the ServiceManagerConfig and ViewManager . These configuration directives can go to the config/autoload/{{,*.}global,{,*.}local}.php files, or in the module/<module name>/config/module.config.php configuration files. The merging of these configuration files is done by the ModuleManager . It first merges each module's module.config.php file, and then the files in config/autoload (first the *.global.php and then the *.local.php files). The order of the merge is relevant so you can override a module's configuration with your application configuration. If you have both a config/autoload/my.global.config.php and config/autoload/my.local.config.php , the local configuration file overrides the global configuration.","title":"Default Configuration Options"},{"location":"cookbook/automating-controller-factories/","text":"Automating Controller Factories Writing a factory class for each and every controller that has dependencies can be tedious, particularly in early development as you are still sorting out dependencies. As of version 3.0.1, laminas-mvc ships with Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory , which provides a reflection-based approach to controller instantiation, resolving constructor dependencies to the relevant services. The factory may be used as either an abstract factory, or mapped to specific controller names as a factory: use Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory; return [ /* ... */ 'controllers' => [ 'abstract_factories' => [ LazyControllerAbstractFactory::class, ], 'factories' => [ 'MyModule\\Controller\\FooController' => LazyControllerAbstractFactory::class, ], ], /* ... */ ]; Mapping controllers to the factory is more explicit and performant. The factory operates with the following constraints/features: A parameter named $config typehinted as an array will receive the application \"config\" service (i.e., the merged configuration). Parameters typehinted against array, but not named $config , will be injected with an empty array. Scalar parameters will be resolved as null values. If a service cannot be found for a given typehint, the factory will raise an exception detailing this. Some services provided by Laminas components do not have entries based on their class name (for historical reasons); the factory contains a map of these class/interface names to the corresponding service name to allow them to resolve. These include: Laminas\\Console\\Adapter\\AdapterInterface maps to ConsoleAdapter , Laminas\\Filter\\FilterPluginManager maps to FilterManager , Laminas\\Hydrator\\HydratorPluginManager maps to HydratorManager , Laminas\\InputFilter\\InputFilterPluginManager maps to InputFilterManager , Laminas\\Log\\FilterPluginManager maps to LogFilterManager , Laminas\\Log\\FormatterPluginManager maps to LogFormatterManager , Laminas\\Log\\ProcessorPluginManager maps to LogProcessorManager , Laminas\\Log\\WriterPluginManager maps to LogWriterManager , Laminas\\Serializer\\AdapterPluginManager maps to SerializerAdapterManager , Laminas\\Validator\\ValidatorPluginManager maps to ValidatorManager , $options passed to the factory are ignored in all cases, as we cannot make assumptions about which argument(s) they might replace. Once your dependencies have stabilized, we recommend writing a dedicated factory, as reflection can introduce performance overhead. References This feature was inspired by a blog post by Alexandre Lemaire .","title":"Automating controller factories"},{"location":"cookbook/automating-controller-factories/#automating-controller-factories","text":"Writing a factory class for each and every controller that has dependencies can be tedious, particularly in early development as you are still sorting out dependencies. As of version 3.0.1, laminas-mvc ships with Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory , which provides a reflection-based approach to controller instantiation, resolving constructor dependencies to the relevant services. The factory may be used as either an abstract factory, or mapped to specific controller names as a factory: use Laminas\\Mvc\\Controller\\LazyControllerAbstractFactory; return [ /* ... */ 'controllers' => [ 'abstract_factories' => [ LazyControllerAbstractFactory::class, ], 'factories' => [ 'MyModule\\Controller\\FooController' => LazyControllerAbstractFactory::class, ], ], /* ... */ ]; Mapping controllers to the factory is more explicit and performant. The factory operates with the following constraints/features: A parameter named $config typehinted as an array will receive the application \"config\" service (i.e., the merged configuration). Parameters typehinted against array, but not named $config , will be injected with an empty array. Scalar parameters will be resolved as null values. If a service cannot be found for a given typehint, the factory will raise an exception detailing this. Some services provided by Laminas components do not have entries based on their class name (for historical reasons); the factory contains a map of these class/interface names to the corresponding service name to allow them to resolve. These include: Laminas\\Console\\Adapter\\AdapterInterface maps to ConsoleAdapter , Laminas\\Filter\\FilterPluginManager maps to FilterManager , Laminas\\Hydrator\\HydratorPluginManager maps to HydratorManager , Laminas\\InputFilter\\InputFilterPluginManager maps to InputFilterManager , Laminas\\Log\\FilterPluginManager maps to LogFilterManager , Laminas\\Log\\FormatterPluginManager maps to LogFormatterManager , Laminas\\Log\\ProcessorPluginManager maps to LogProcessorManager , Laminas\\Log\\WriterPluginManager maps to LogWriterManager , Laminas\\Serializer\\AdapterPluginManager maps to SerializerAdapterManager , Laminas\\Validator\\ValidatorPluginManager maps to ValidatorManager , $options passed to the factory are ignored in all cases, as we cannot make assumptions about which argument(s) they might replace. Once your dependencies have stabilized, we recommend writing a dedicated factory, as reflection can introduce performance overhead.","title":"Automating Controller Factories"},{"location":"cookbook/automating-controller-factories/#references","text":"This feature was inspired by a blog post by Alexandre Lemaire .","title":"References"},{"location":"cookbook/middleware-in-listeners/","text":"Using middleware within event listeners Within the MVC workflow, you can use middleware within event listeners by converting the request and response objects composed in the event to PSR-7 equivalents using laminas-psr7bridge . As an example, consider the following AuthorizationMiddleware : namespace Application\\Middleware; use Psr\\Http\\Message\\ServerRequestInterface as RequestInterface; use Psr\\Http\\Message\\ResponseInterface; class AuthorizationMiddleware { public function __invoke(RequestInterface $request, ResponseInterface $response, callable $next = null) { // handle authorization here... } } Since the request and response composed in MvcEvent instances are specifically from laminas-http, we will use laminas-psr7bridge to convert them to PSR-7 equivalents. As an example, consider the following module declaration, which registers a dispatch listener to invoke the above middleware: namespace Application; use Psr\\Http\\Message\\ResponseInterface; use Laminas\\Psr7Bridge\\Psr7ServerRequest; use Laminas\\Psr7Bridge\\Psr7Response; class Module { public function onBootstrap($e) { $app = $e->getApplication(); $eventManager = $app->getEventManager(); $services = $app->getServiceManager(); $eventManager->attach($e::EVENT_DISPATCH, function ($e) use ($services) { $request = Psr7ServerRequest::fromLaminas($e->getRequest()); $response = Psr7Response::fromLaminas($e->getResponse()); $done = function ($request, $response) { }; $result = ($services->get(Middleware\\AuthorizationMiddleware::class))( $request, $response, $done ); if ($result) { return Psr7Response::toLaminas($result); } }, 2); } }","title":"Using middleware within event listeners"},{"location":"cookbook/middleware-in-listeners/#using-middleware-within-event-listeners","text":"Within the MVC workflow, you can use middleware within event listeners by converting the request and response objects composed in the event to PSR-7 equivalents using laminas-psr7bridge . As an example, consider the following AuthorizationMiddleware : namespace Application\\Middleware; use Psr\\Http\\Message\\ServerRequestInterface as RequestInterface; use Psr\\Http\\Message\\ResponseInterface; class AuthorizationMiddleware { public function __invoke(RequestInterface $request, ResponseInterface $response, callable $next = null) { // handle authorization here... } } Since the request and response composed in MvcEvent instances are specifically from laminas-http, we will use laminas-psr7bridge to convert them to PSR-7 equivalents. As an example, consider the following module declaration, which registers a dispatch listener to invoke the above middleware: namespace Application; use Psr\\Http\\Message\\ResponseInterface; use Laminas\\Psr7Bridge\\Psr7ServerRequest; use Laminas\\Psr7Bridge\\Psr7Response; class Module { public function onBootstrap($e) { $app = $e->getApplication(); $eventManager = $app->getEventManager(); $services = $app->getServiceManager(); $eventManager->attach($e::EVENT_DISPATCH, function ($e) use ($services) { $request = Psr7ServerRequest::fromLaminas($e->getRequest()); $response = Psr7Response::fromLaminas($e->getResponse()); $done = function ($request, $response) { }; $result = ($services->get(Middleware\\AuthorizationMiddleware::class))( $request, $response, $done ); if ($result) { return Psr7Response::toLaminas($result); } }, 2); } }","title":"Using middleware within event listeners"},{"location":"migration/","text":"Migration While we strive to keep functionality backwards compatible between releases, occasionally we need to break features in order to fix critical or security issues. Additionally, in order to signal upcoming changes, we will introduce deprecation notices or add forwards-compatibility features to assist you in migration. The chapters in this section document these changes. Migrating from v2.X to v2.7 Migrating to v3.0","title":"Migration Overview"},{"location":"migration/#migration","text":"While we strive to keep functionality backwards compatible between releases, occasionally we need to break features in order to fix critical or security issues. Additionally, in order to signal upcoming changes, we will introduce deprecation notices or add forwards-compatibility features to assist you in migration. The chapters in this section document these changes. Migrating from v2.X to v2.7 Migrating to v3.0","title":"Migration"},{"location":"migration/to-v2-7/","text":"Upgrading to 2.7 Middleware laminas-mvc now registers Laminas\\Mvc\\MiddlewareListener as a dispatch listener at a priority higher than Laminas\\Mvc\\DispatchListener , allowing dispatch of PSR-7 middleware. Read the middleware chapter for details on how to use this new feature. Application The constructor signature of Laminas\\Mvc\\Application has changed. Previously, it was: __construct($configuration, ServiceManager $serviceManager) and internally, it pulled the services EventManager , Request , and Response from the provided $serviceManager during initialization. The new constructor signature provides optional arguments for injecting the event manager, request, and response: __construct( $configuration, ServiceManager $serviceManager, EventManager $events = null, RequestInterface $request = null, ResponseInterface $response = null ) This change makes all dependencies explicit. Starting in v3.0, the new arguments will be required . The factory Laminas\\Mvc\\Service\\ApplicationFactory was updated to follow the new signature. This change should only affect users who are manually instantiating the Application instance. EventManagerAware initializers laminas-mvc provides two mechanisms for injecting event managers into EventManagerAware objects. One is the \"EventManagerAwareInitializer\" registered in Laminas\\Mvc\\Service\\ServiceManagerConfig , and the other is the Laminas\\Mvc\\Controller\\ControllerManager::injectEventManager() initializer. In both cases, the logic was updated to be forwards compatible with laminas-eventmanager v3. Previously each would check if the instance's getEventManager() method returned an event manager instance, and, if so, inject the shared event manager: $events = $instance->getEventManager(); if ($events instanceof EventManagerInterface) { $events->setSharedManager($container->get('SharedEventManager')); } In laminas-eventmanager v3, event managers are now injected with the shared manager at instantiation, and no setter exists for providing the shared manager. As such, the above logic changed to: $events = $instance->getEventManager(); if (! $events || ! $events->getSharedManager()) { $instance->setEventManager($container->get('EventManager')); } In other words, it re-injects with a new event manager instance if the instance pulled does not have a shared manager composed. This likely will not cause regressions in existing code, but may be something to be aware of if you were previously depending on lazy-loaded event manager state. ServiceLocatorAware initializers laminas-servicemanager v3.0 removes Laminas\\ServiceManager\\ServiceLocatorAwareInterface . Since laminas-mvc provides initializers around that interface, they needed updates to allow both forwards compatibility with laminas-servicemanager v3 as well as backwards compatibility with existing applications. This was accomplished in two ways: The abstract controller implementations no longer implement ServiceLocatorAwareInterface , but continue to define the methods that the interface defines (namely setServiceLocator() and getServiceLocator() . The initializers registered by Laminas\\Mvc\\Service\\ServiceManagerConfig and Laminas\\Mvc\\Controller\\ControllerManager now use duck-typing to determine if an instance requires container injection; if so it will do so. However, we also maintain that service locator injection is an anti-pattern; dependencies should be injected directly into instances instead. As such, starting in 2.7.0, we now emit a deprecation notice any time an instance is injected by one of these initializers, and we plan to remove the initializers for version 3.0. The deprecation notice includes the name of the class, to help you identify what instances you will need to update before the laminas-mvc v3 release. To prepare your code, you will need to do the following within your controller: Find all cases where you call getServiceLocator() , and identify the services they retrieve. Update your controller to accept these services via the constructor. If you have not already, create a factory class for your controller. In the factory, pull the appropriate services and pass them to the controller's constructor. As an example, consider the following code from a controller: $db = $this->getServiceLcoator()->get('Db\\ApplicationAdapter'); To update your controller, you will: Add a $db property to your class. Update the constructor to accept the database adapter and assign it to the $db property. Change the above line to either read $db = $this->db; or just use the property directly . Add a factory that pulls the service and pushes it into the controller. The controller then might look like the following: use Laminas\\Db\\Adapter\\AdapterInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; class YourController extends AbstractActionController { private $db; public function __construct(AdapterInterface $db) { $this->db = $db; } public function someAction() { $results = $this->db->query(/* ... */); /* ... */ } } A factory would look like the following: use Interop\\Container\\ContainerInterface; class YourControllerFactory { public function __invoke(ContainerInterface $container) { return new YourController($container->get('Db\\ApplicationAdapter')); } } You then also need to ensure the controller manager knows about the factory. It likely already does, as an invokable; you will redefine it as a factory in your module.config.php : return [ 'controllers' => [ 'factories' => [ YourController::class => YourControllerFactory::class, /* ... */ ], /* ... */ ], /* ... */ ]; While this may seem like more steps, doing so ensures your code has no hidden dependencies, improves the testability of your code, and allows you to substitute alternatives for either the dependencies or the controller itself. Optional dependencies In some cases, you may have dependencies that are only required for some execution paths, such as forms, database adapters, etc. In these cases, you have two approaches you can use: Split your controller into separate responsibilities, and use the more specific controllers. This way you don't need to inject dependencies that are only used in some actions. (We recommend doing this regardless, as it helps keep your code more maintainable.) Use lazy services . When you configure these, laminas-servicemanager gives you a proxy instance that, on first access, loads the full service. This allows you to delay the most expensive operations until absolutely needed.","title":"v2.X to v2.7"},{"location":"migration/to-v2-7/#upgrading-to-27","text":"","title":"Upgrading to 2.7"},{"location":"migration/to-v2-7/#middleware","text":"laminas-mvc now registers Laminas\\Mvc\\MiddlewareListener as a dispatch listener at a priority higher than Laminas\\Mvc\\DispatchListener , allowing dispatch of PSR-7 middleware. Read the middleware chapter for details on how to use this new feature.","title":"Middleware"},{"location":"migration/to-v2-7/#application","text":"The constructor signature of Laminas\\Mvc\\Application has changed. Previously, it was: __construct($configuration, ServiceManager $serviceManager) and internally, it pulled the services EventManager , Request , and Response from the provided $serviceManager during initialization. The new constructor signature provides optional arguments for injecting the event manager, request, and response: __construct( $configuration, ServiceManager $serviceManager, EventManager $events = null, RequestInterface $request = null, ResponseInterface $response = null ) This change makes all dependencies explicit. Starting in v3.0, the new arguments will be required . The factory Laminas\\Mvc\\Service\\ApplicationFactory was updated to follow the new signature. This change should only affect users who are manually instantiating the Application instance.","title":"Application"},{"location":"migration/to-v2-7/#eventmanageraware-initializers","text":"laminas-mvc provides two mechanisms for injecting event managers into EventManagerAware objects. One is the \"EventManagerAwareInitializer\" registered in Laminas\\Mvc\\Service\\ServiceManagerConfig , and the other is the Laminas\\Mvc\\Controller\\ControllerManager::injectEventManager() initializer. In both cases, the logic was updated to be forwards compatible with laminas-eventmanager v3. Previously each would check if the instance's getEventManager() method returned an event manager instance, and, if so, inject the shared event manager: $events = $instance->getEventManager(); if ($events instanceof EventManagerInterface) { $events->setSharedManager($container->get('SharedEventManager')); } In laminas-eventmanager v3, event managers are now injected with the shared manager at instantiation, and no setter exists for providing the shared manager. As such, the above logic changed to: $events = $instance->getEventManager(); if (! $events || ! $events->getSharedManager()) { $instance->setEventManager($container->get('EventManager')); } In other words, it re-injects with a new event manager instance if the instance pulled does not have a shared manager composed. This likely will not cause regressions in existing code, but may be something to be aware of if you were previously depending on lazy-loaded event manager state.","title":"EventManagerAware initializers"},{"location":"migration/to-v2-7/#servicelocatoraware-initializers","text":"laminas-servicemanager v3.0 removes Laminas\\ServiceManager\\ServiceLocatorAwareInterface . Since laminas-mvc provides initializers around that interface, they needed updates to allow both forwards compatibility with laminas-servicemanager v3 as well as backwards compatibility with existing applications. This was accomplished in two ways: The abstract controller implementations no longer implement ServiceLocatorAwareInterface , but continue to define the methods that the interface defines (namely setServiceLocator() and getServiceLocator() . The initializers registered by Laminas\\Mvc\\Service\\ServiceManagerConfig and Laminas\\Mvc\\Controller\\ControllerManager now use duck-typing to determine if an instance requires container injection; if so it will do so. However, we also maintain that service locator injection is an anti-pattern; dependencies should be injected directly into instances instead. As such, starting in 2.7.0, we now emit a deprecation notice any time an instance is injected by one of these initializers, and we plan to remove the initializers for version 3.0. The deprecation notice includes the name of the class, to help you identify what instances you will need to update before the laminas-mvc v3 release. To prepare your code, you will need to do the following within your controller: Find all cases where you call getServiceLocator() , and identify the services they retrieve. Update your controller to accept these services via the constructor. If you have not already, create a factory class for your controller. In the factory, pull the appropriate services and pass them to the controller's constructor. As an example, consider the following code from a controller: $db = $this->getServiceLcoator()->get('Db\\ApplicationAdapter'); To update your controller, you will: Add a $db property to your class. Update the constructor to accept the database adapter and assign it to the $db property. Change the above line to either read $db = $this->db; or just use the property directly . Add a factory that pulls the service and pushes it into the controller. The controller then might look like the following: use Laminas\\Db\\Adapter\\AdapterInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; class YourController extends AbstractActionController { private $db; public function __construct(AdapterInterface $db) { $this->db = $db; } public function someAction() { $results = $this->db->query(/* ... */); /* ... */ } } A factory would look like the following: use Interop\\Container\\ContainerInterface; class YourControllerFactory { public function __invoke(ContainerInterface $container) { return new YourController($container->get('Db\\ApplicationAdapter')); } } You then also need to ensure the controller manager knows about the factory. It likely already does, as an invokable; you will redefine it as a factory in your module.config.php : return [ 'controllers' => [ 'factories' => [ YourController::class => YourControllerFactory::class, /* ... */ ], /* ... */ ], /* ... */ ]; While this may seem like more steps, doing so ensures your code has no hidden dependencies, improves the testability of your code, and allows you to substitute alternatives for either the dependencies or the controller itself.","title":"ServiceLocatorAware initializers"},{"location":"migration/to-v3-0/","text":"Upgrading to 3.0 With the release of Laminas, all components current at that time, regardless of history, were tagged as v2 releases; in reality, it was the first version of a new framework, as it was a completely new architecture from Laminas Framework 1. As such, laminas-mvc 3.0 marks the second major release of the component. The primary goal for version 3 was to reduce the number of dependencies, and to split out unrelated, tangential, or extension functionality. As such, there are a number of changes that will impact users. Dependency reduction In order to remove dependencies, we needed to provide alternate ways to ensure that default functionality, such as service registration and event listener attachment, could still occur. The solution to this problem was to expose each component as a module. This however, raised another problem: you now have to register components as modules in your application. To solve this new problem, we created a new component, laminas-component-installer . Install this in your application now: $ composer require --dev laminas/laminas-component-installer Once installed, the component acts as a Composer plugin, and will intercept packages marked as components or Laminas modules, and register them with your application configuration. Components are pushed to the top of the module list, while modules are pushed to the end. As a development component, it will not be installed in your production distributions. Updated dependencies The v3 release now requires : laminas-http laminas-modulemanager laminas-router laminas-view Additionally, the following components require their v3 releases: laminas-eventmanager laminas-servicemanager laminas-stdlib The minimum supported PHP version was bumped to 5.6. Application class The following changes were made to the Laminas\\Mvc\\Application constructor: The first $configuration argument was removed, as it was not used. Three additional, optional arguments were added: Laminas\\EventManager\\EventManagerInterface $events = null Laminas\\Stdlib\\RequestInterface $request = null Laminas\\Stdlib\\ResponseInterface $response = null End-users using the skeleton application and the default Application factory will not notice a change. Those who are directly instantiating the Application instance (in production or test code) or who have created their own factory for the class will need to update their code. send method The send() method has been deprecated since the 2.2 release, and a no-op since then as well. It is removed starting with the v3 release. ControllerLoader The ControllerLoader service was deprecated early in the v2 lifecycle, and aliased to ControllerManager . The ControllerLoader factory was kept to prevent BC breaks due to extending the class. v3 removes the ControllerLoaderFactory , as well as the ControllerLoader service alias. DI-ServiceManager integration The integration between laminas-servicemanager and laminas-di has been moved to a new standalone component, laminas-servicemanager-di . In most cases, installing the component will restore the original behavior: $ composer require laminas/laminas-servicemanager-di Manual installation The above assumes you're using the new component installer detailed in the dependency reduction section, above. If you are not, you will need to inject the laminas-servicemanager-di module into your application manually; follow the instructions in the laminas-servicemanager-di documentation to do so. The new component also contains a migration document detailing potential issues for users migrating to version 3. DispatchListener The marshallControllerNotFoundEvent() method was deprecated early in the Laminas lifecycle, and has proxied to marshalControllerNotFoundEvent() . It is removed with the v3 release. Routing Routing was removed from laminas-mvc, and moved to a new component, laminas-router , which is now a dependency of laminas-mvc. The changes that will impact users are: Query route removal ; this route had been deprecated since 2.3.0, and removed for the 3.0 release. Namespace changes ; with the separation to the laminas-router component, all routes changed namespaces from Laminas\\Mvc\\Router to Laminas\\Router . Follow the links above for more details on these changes, and how to migrate your code. Console tooling Console tooling, including console routes, were split off to a new component, laminas-mvc-console . If you were using the console tooling, install laminas-mvc-console: $ composer require laminas/laminas-mvc-console (Make sure you've already installed laminas-component-installer before you do, to ensure the component is registered with your application!) laminas-mvc-console exposes all of the same functionality as was in the v2 series of laminas-mvc, but most components are in different namespaces. Please read the laminas-mvc-console migration guide for full details of what changes you may need to make to your application to ensure console tooling continues to work. Migrate your console tooling Due to the amount of integration required to support console tooling via the MVC, we do not plan on supporting laminas-mvc-console long-term. As such, we recommend migrating your code to use standalone tools such as zf-console or Aura.Cli . Filter integration In version 2, laminas-mvc exposed a FilterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide filter configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-filter component itself. To add it, install laminas-filter: $ composer require laminas/laminas-filter Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . Form integration In version 2, laminas-mvc exposed several facilities related to laminas-form: FormElementManager mapped to a factory in laminas-mvc, but created a Laminas\\Form\\FormElementManager instance. FormAnnotationBuilder mapped to a factory in laminas-mvc, but created a Laminas\\Form\\Annotation\\AnnotationBuilder instance. The ServiceListenerFactory registered Laminas\\Form\\FormAbstractServiceFactory as an abstract factory. The ModuleManagerFactory registered specifications with the laminas-modulemanager ServiceListener to allow modules to provide form element configuration. The above functionality is now removed from laminas-mvc, and exposed directly by the laminas-form component. To add/enable it, install laminas-form: $ composer require laminas/laminas-form Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . Hydrator integration In version 2, laminas-mvc exposed a HydratorManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide hydrator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-hydrator component itself. To add it, install laminas-hydrator: $ composer require laminas/laminas-hydrator Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . InputFilter integration In version 2, laminas-mvc exposed a InputFilterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide validator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-inputfilter component itself. To add it, install laminas-inputfilter: $ composer require laminas/laminas-inputfilter Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . laminas-inputfilter now also exposes the InputFilterAbstractServiceFactory as an abstract factory by default. i18n integration Internationalization tooling, including: the integration translator ( MvcTranslator service) the \"dummy\" translator the TranslatorAwareTreeRouteStack implementation factories for the translator and translator loader managers were removed, and re-assigned to the laminas-i18n and laminas-mvc-i18n packages. In most cases, you can install laminas/laminas-mvc-i18n to restore i18n functionality to your application: $ composer require laminas/laminas-mvc-i18n There are two categories of changes that could affect you on upgrading. First, if you were using the TranslatorAwareTreeRouteStack , the class name has changed from Laminas\\Mvc\\Router\\Http\\TranslatorAwareTreeRouteStack to Laminas\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack ; updating your code to reflect that will allow it to work again. Second, if you were extending one of the service factories for either the MvcTranslator or the TranslatorPluginManager , the namespaces for the factories have changed. In such situations, you have two options: Update your extensions to extend the new classes. See the laminas-mvc-i18n migration guide to determine what names have changed. Instead of extending, consider using delegator factories , as these decorate the service factory, regardless of what factory is used. Log integration In version 2, laminas-mvc exposed LogProcessorManager and LogWriterManager services by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide configuration for each. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-log component itself. To add it, install laminas-log: $ composer require laminas/laminas-log Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . laminas-log now also exposes LogFilterManager and LogFormatterManager , corresponding to the following: Service Config Key Provider Interface Provider Method LogFilterManager log_filters Laminas\\Log\\Filter\\LogFilterProviderInterface getLogFilterConfig() LogFormatterManager log_formatters Laminas\\Log\\Formatter\\LogFormatterProviderInterface getLogFormatterConfig() This additions allow you to provide additional plugins for every aspect laminas-log exposes. Plugins The following plugins have been removed from the main laminas-mvc repository, and into their own standalone repositories. In all cases, please be sure to install the component installer as detailed above before installing the plugins, to automate injection into your application configuration. fileprg() The fileprg() plugin is now provided via the laminas-mvc-plugin-fileprg component. $ composer require laminas/laminas-mvc-plugin-fileprg Laminas\\Mvc\\Controller\\Plugin\\FilePostRedirectGet becomes Laminas\\Mvc\\Plugin\\FilePrg\\FilePostRedirectGet . However, it is still mapped as fileprg() . flashMessenger() The flashMessenger() plugin is now provided via the laminas-mvc-plugin-flashmessenger component. $ composer require laminas/laminas-mvc-plugin-flashmessenger Laminas\\Mvc\\Controller\\Plugin\\FlashMessenger becomes Laminas\\Mvc\\Plugin\\FlashMessenger\\FlashMessenger . However, it is still mapped as flashMessenger() and flashmessenger() . identity() The identity() plugin is now provided via the laminas-mvc-plugin-identity component. $ composer require laminas/laminas-mvc-plugin-identity Laminas\\Mvc\\Controller\\Plugin\\Identity becomes Laminas\\Mvc\\Plugin\\Identity\\Identity . However, it is still mapped as identity() . Additionally, Laminas\\Mvc\\Controller\\Plugin\\Service\\IdentityFactory now becomes Laminas\\Mvc\\Plugin\\Identity\\IdentityFactory . prg() The prg() plugin is now provided via the laminas-mvc-plugin-prg component. $ composer require laminas/laminas-mvc-plugin-prg Laminas\\Mvc\\Controller\\Plugin\\PostRedirectGet becomes Laminas\\Mvc\\Plugin\\Prg\\PostRedirectGet . However, it is still mapped as prg() . Serializer integration In version 2, laminas-mvc exposed a SerializerAdapterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide serializer configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-serializer component itself. To add it, install laminas-serializer $ composer require laminas/laminas-serializer Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . ServiceLocatorAware initializers Starting with laminas-servicemanager v3, that component no longer defines the ServiceLocatorAwareInterface . Since laminas-mvc pins against laminas-servicemanager v3 with its own v3 release, the initializers that injected the application container into implementations of that interface are no longer relevant. As such, they have now been removed from each of the Laminas\\Mvc\\Service\\ServiceManagerConfig and Laminas\\Mvc\\Controller\\ControllerManager classes. Additionally, the duck-typed ServiceLocatorAwareInterface implementation in AbstractController was removed, as messaged in the 2.7 release. If you relied on this functionality, you are encouraged to update your code to use factories to inject your actual dependencies. Validator integration In version 2, laminas-mvc exposed a ValidatorManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide validator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-validator component itself. To add it, install laminas-validator: $ composer require laminas/laminas-validator Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . Laminas\\Mvc\\View\\InjectTemplateListener The InjectTemplateListener attempts to map a controller name to a template using a variety of heuristics, including an explicit map provided during configuration, or auto-detection based on the controller class name. In version 2, the autodetection took into consideration the __NAMESPACE__ route match parameter to derive subnamespaces, or would omit them completely if __NAMESPACE__ was not present. This caused issues when multiple modules shared a top-level namespace (e.g., Laminas\\ApiTools and Laminas\\ApiTools\\Admin ) and each had a controller with the same name. To avoid naming conflicts, version 3 removes this aspect of autodetection, and instead provides exactly one workflow for mapping: Strip the Controller subnamespace, if present (e.g., the namespace Application\\Controller\\\\ is normalized to Application\\\\ ). Strip the Controller suffix in the class name, if present (e.g., IndexController is normalized to Index ). Inflect CamelCasing to dash-separated (e.g., ShowUsers becomes show-users ). Replace the namespace separator with a slash. As a full example, the controller service name TestSomething\\With\\Controller\\CamelCaseController will always map to test-something/with/camel-case , regardless of the __NAMESPACE__ value provided in routing configuration. If needed, you can emulate the version 2 behavior in version 3 via namespace whitelisting in the controller <=> template map. Laminas\\Mvc\\View\\SendResponseListener Laminas\\Mvc\\View\\SendResponseListener was deprecated with the 2.2 release, and has been an extension of Laminas\\Mvc\\SendResponseListener ever since. It is removed with the v3 release.","title":"v2.X to v3.0"},{"location":"migration/to-v3-0/#upgrading-to-30","text":"With the release of Laminas, all components current at that time, regardless of history, were tagged as v2 releases; in reality, it was the first version of a new framework, as it was a completely new architecture from Laminas Framework 1. As such, laminas-mvc 3.0 marks the second major release of the component. The primary goal for version 3 was to reduce the number of dependencies, and to split out unrelated, tangential, or extension functionality. As such, there are a number of changes that will impact users.","title":"Upgrading to 3.0"},{"location":"migration/to-v3-0/#dependency-reduction","text":"In order to remove dependencies, we needed to provide alternate ways to ensure that default functionality, such as service registration and event listener attachment, could still occur. The solution to this problem was to expose each component as a module. This however, raised another problem: you now have to register components as modules in your application. To solve this new problem, we created a new component, laminas-component-installer . Install this in your application now: $ composer require --dev laminas/laminas-component-installer Once installed, the component acts as a Composer plugin, and will intercept packages marked as components or Laminas modules, and register them with your application configuration. Components are pushed to the top of the module list, while modules are pushed to the end. As a development component, it will not be installed in your production distributions.","title":"Dependency reduction"},{"location":"migration/to-v3-0/#updated-dependencies","text":"The v3 release now requires : laminas-http laminas-modulemanager laminas-router laminas-view Additionally, the following components require their v3 releases: laminas-eventmanager laminas-servicemanager laminas-stdlib The minimum supported PHP version was bumped to 5.6.","title":"Updated dependencies"},{"location":"migration/to-v3-0/#application-class","text":"The following changes were made to the Laminas\\Mvc\\Application constructor: The first $configuration argument was removed, as it was not used. Three additional, optional arguments were added: Laminas\\EventManager\\EventManagerInterface $events = null Laminas\\Stdlib\\RequestInterface $request = null Laminas\\Stdlib\\ResponseInterface $response = null End-users using the skeleton application and the default Application factory will not notice a change. Those who are directly instantiating the Application instance (in production or test code) or who have created their own factory for the class will need to update their code.","title":"Application class"},{"location":"migration/to-v3-0/#controllerloader","text":"The ControllerLoader service was deprecated early in the v2 lifecycle, and aliased to ControllerManager . The ControllerLoader factory was kept to prevent BC breaks due to extending the class. v3 removes the ControllerLoaderFactory , as well as the ControllerLoader service alias.","title":"ControllerLoader"},{"location":"migration/to-v3-0/#di-servicemanager-integration","text":"The integration between laminas-servicemanager and laminas-di has been moved to a new standalone component, laminas-servicemanager-di . In most cases, installing the component will restore the original behavior: $ composer require laminas/laminas-servicemanager-di","title":"DI-ServiceManager integration"},{"location":"migration/to-v3-0/#dispatchlistener","text":"The marshallControllerNotFoundEvent() method was deprecated early in the Laminas lifecycle, and has proxied to marshalControllerNotFoundEvent() . It is removed with the v3 release.","title":"DispatchListener"},{"location":"migration/to-v3-0/#routing","text":"Routing was removed from laminas-mvc, and moved to a new component, laminas-router , which is now a dependency of laminas-mvc. The changes that will impact users are: Query route removal ; this route had been deprecated since 2.3.0, and removed for the 3.0 release. Namespace changes ; with the separation to the laminas-router component, all routes changed namespaces from Laminas\\Mvc\\Router to Laminas\\Router . Follow the links above for more details on these changes, and how to migrate your code.","title":"Routing"},{"location":"migration/to-v3-0/#console-tooling","text":"Console tooling, including console routes, were split off to a new component, laminas-mvc-console . If you were using the console tooling, install laminas-mvc-console: $ composer require laminas/laminas-mvc-console (Make sure you've already installed laminas-component-installer before you do, to ensure the component is registered with your application!) laminas-mvc-console exposes all of the same functionality as was in the v2 series of laminas-mvc, but most components are in different namespaces. Please read the laminas-mvc-console migration guide for full details of what changes you may need to make to your application to ensure console tooling continues to work.","title":"Console tooling"},{"location":"migration/to-v3-0/#filter-integration","text":"In version 2, laminas-mvc exposed a FilterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide filter configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-filter component itself. To add it, install laminas-filter: $ composer require laminas/laminas-filter Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Filter integration"},{"location":"migration/to-v3-0/#form-integration","text":"In version 2, laminas-mvc exposed several facilities related to laminas-form: FormElementManager mapped to a factory in laminas-mvc, but created a Laminas\\Form\\FormElementManager instance. FormAnnotationBuilder mapped to a factory in laminas-mvc, but created a Laminas\\Form\\Annotation\\AnnotationBuilder instance. The ServiceListenerFactory registered Laminas\\Form\\FormAbstractServiceFactory as an abstract factory. The ModuleManagerFactory registered specifications with the laminas-modulemanager ServiceListener to allow modules to provide form element configuration. The above functionality is now removed from laminas-mvc, and exposed directly by the laminas-form component. To add/enable it, install laminas-form: $ composer require laminas/laminas-form Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Form integration"},{"location":"migration/to-v3-0/#hydrator-integration","text":"In version 2, laminas-mvc exposed a HydratorManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide hydrator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-hydrator component itself. To add it, install laminas-hydrator: $ composer require laminas/laminas-hydrator Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Hydrator integration"},{"location":"migration/to-v3-0/#inputfilter-integration","text":"In version 2, laminas-mvc exposed a InputFilterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide validator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-inputfilter component itself. To add it, install laminas-inputfilter: $ composer require laminas/laminas-inputfilter Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . laminas-inputfilter now also exposes the InputFilterAbstractServiceFactory as an abstract factory by default.","title":"InputFilter integration"},{"location":"migration/to-v3-0/#i18n-integration","text":"Internationalization tooling, including: the integration translator ( MvcTranslator service) the \"dummy\" translator the TranslatorAwareTreeRouteStack implementation factories for the translator and translator loader managers were removed, and re-assigned to the laminas-i18n and laminas-mvc-i18n packages. In most cases, you can install laminas/laminas-mvc-i18n to restore i18n functionality to your application: $ composer require laminas/laminas-mvc-i18n There are two categories of changes that could affect you on upgrading. First, if you were using the TranslatorAwareTreeRouteStack , the class name has changed from Laminas\\Mvc\\Router\\Http\\TranslatorAwareTreeRouteStack to Laminas\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack ; updating your code to reflect that will allow it to work again. Second, if you were extending one of the service factories for either the MvcTranslator or the TranslatorPluginManager , the namespaces for the factories have changed. In such situations, you have two options: Update your extensions to extend the new classes. See the laminas-mvc-i18n migration guide to determine what names have changed. Instead of extending, consider using delegator factories , as these decorate the service factory, regardless of what factory is used.","title":"i18n integration"},{"location":"migration/to-v3-0/#log-integration","text":"In version 2, laminas-mvc exposed LogProcessorManager and LogWriterManager services by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide configuration for each. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-log component itself. To add it, install laminas-log: $ composer require laminas/laminas-log Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction . laminas-log now also exposes LogFilterManager and LogFormatterManager , corresponding to the following: Service Config Key Provider Interface Provider Method LogFilterManager log_filters Laminas\\Log\\Filter\\LogFilterProviderInterface getLogFilterConfig() LogFormatterManager log_formatters Laminas\\Log\\Formatter\\LogFormatterProviderInterface getLogFormatterConfig() This additions allow you to provide additional plugins for every aspect laminas-log exposes.","title":"Log integration"},{"location":"migration/to-v3-0/#plugins","text":"The following plugins have been removed from the main laminas-mvc repository, and into their own standalone repositories. In all cases, please be sure to install the component installer as detailed above before installing the plugins, to automate injection into your application configuration.","title":"Plugins"},{"location":"migration/to-v3-0/#serializer-integration","text":"In version 2, laminas-mvc exposed a SerializerAdapterManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide serializer configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-serializer component itself. To add it, install laminas-serializer $ composer require laminas/laminas-serializer Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Serializer integration"},{"location":"migration/to-v3-0/#servicelocatoraware-initializers","text":"Starting with laminas-servicemanager v3, that component no longer defines the ServiceLocatorAwareInterface . Since laminas-mvc pins against laminas-servicemanager v3 with its own v3 release, the initializers that injected the application container into implementations of that interface are no longer relevant. As such, they have now been removed from each of the Laminas\\Mvc\\Service\\ServiceManagerConfig and Laminas\\Mvc\\Controller\\ControllerManager classes. Additionally, the duck-typed ServiceLocatorAwareInterface implementation in AbstractController was removed, as messaged in the 2.7 release. If you relied on this functionality, you are encouraged to update your code to use factories to inject your actual dependencies.","title":"ServiceLocatorAware initializers"},{"location":"migration/to-v3-0/#validator-integration","text":"In version 2, laminas-mvc exposed a ValidatorManager service by default, and provided specifications to laminas-modulemanager's ServiceListener to allow modules to provide validator configuration. This functionality is now removed from laminas-mvc. It is now exposed directly by the laminas-validator component itself. To add it, install laminas-validator: $ composer require laminas/laminas-validator Note: the above assumes you have already installed laminas-component-installer, per the section above on dependency reduction .","title":"Validator integration"},{"location":"migration/to-v3-0/#laminasmvcviewinjecttemplatelistener","text":"The InjectTemplateListener attempts to map a controller name to a template using a variety of heuristics, including an explicit map provided during configuration, or auto-detection based on the controller class name. In version 2, the autodetection took into consideration the __NAMESPACE__ route match parameter to derive subnamespaces, or would omit them completely if __NAMESPACE__ was not present. This caused issues when multiple modules shared a top-level namespace (e.g., Laminas\\ApiTools and Laminas\\ApiTools\\Admin ) and each had a controller with the same name. To avoid naming conflicts, version 3 removes this aspect of autodetection, and instead provides exactly one workflow for mapping: Strip the Controller subnamespace, if present (e.g., the namespace Application\\Controller\\\\ is normalized to Application\\\\ ). Strip the Controller suffix in the class name, if present (e.g., IndexController is normalized to Index ). Inflect CamelCasing to dash-separated (e.g., ShowUsers becomes show-users ). Replace the namespace separator with a slash. As a full example, the controller service name TestSomething\\With\\Controller\\CamelCaseController will always map to test-something/with/camel-case , regardless of the __NAMESPACE__ value provided in routing configuration. If needed, you can emulate the version 2 behavior in version 3 via namespace whitelisting in the controller <=> template map.","title":"Laminas\\Mvc\\View\\InjectTemplateListener"},{"location":"migration/to-v3-0/#laminasmvcviewsendresponselistener","text":"Laminas\\Mvc\\View\\SendResponseListener was deprecated with the 2.2 release, and has been an extension of Laminas\\Mvc\\SendResponseListener ever since. It is removed with the v3 release.","title":"Laminas\\Mvc\\View\\SendResponseListener"}]}